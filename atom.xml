<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>饼干博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-20T11:30:33.930Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>下载GitHub上单个文件(夹)</title>
    <link href="http://example.com/2021/11/20/downgit/"/>
    <id>http://example.com/2021/11/20/downgit/</id>
    <published>2021-11-20T07:28:48.000Z</published>
    <updated>2021-11-20T11:30:33.930Z</updated>
    
    <content type="html"><![CDATA[<img src="https://th.bing.com/th/id/OIP.lEetUExVDCW3Oq0Yl-CtLwHaBl?pid=ImgDet&rs=1"/><span id="more"></span><h3 id="方法一：SVN-下载单个文件夹"><a href="#方法一：SVN-下载单个文件夹" class="headerlink" title="方法一：SVN-下载单个文件夹"></a><a href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ASVN-%E4%B8%8B%E8%BD%BD%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9" title="方法一：SVN-下载单个文件夹"></a>方法一：SVN-下载单个文件夹</h3><blockquote><p>个人最适应的方法，缺点是需要借助第三方工具-svn</p><p>环境：Windows 10</p></blockquote><p>​ 若想要下载<code>&#123;username&#125;</code>的<code>&#123;repo&#125;</code>里的<code>&#123;dir&#125;</code>文件夹，</p><ol><li>主分支master（现在似乎默认是main了，区别不大）：<ul><li>其浏览器路径应为<code>https://github.com/&#123;username&#125;/&#123;repo&#125;/tree/master/&#123;dir&#125;</code></li><li>修改<code>/tree/master/</code>为<code>/trunk/</code></li><li>打开<code>cmd</code>，输入指令：<code>svn checkout https://github.com/&#123;username&#125;/&#123;repo&#125;/trunk/&#123;dir&#125;</code></li><li>该<code>&#123;dir&#125;</code>将被下载至当前目录下  <img src="/medias/loading.gif" alt="示例">  <strong>示例</strong></li></ul></li><li>特定分支<ul><li>  将<code>/trunk/</code>换成<code>/branches/&#123;branch_name&#125;</code>即可</li></ul></li></ol><h3 id="方法二：高版本-Git"><a href="#方法二：高版本-Git" class="headerlink" title="方法二：高版本 Git"></a><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%AB%98%E7%89%88%E6%9C%AC-Git" title="方法二：高版本 Git"></a>方法二：高版本 Git</h3><blockquote><p>这个方法较为繁琐，但无需像前者一样借助其它工具</p></blockquote><p>方法：Git 的<code>Sparse Checkout</code>模式，指定文件/文件夹</p><ol><li>创建空的本地仓库，并将远程 <code>Git Server URL</code> 加入到 <code>Git Config</code>里 none <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir project_folder</span><br><span class="line">cd project_folder</span><br><span class="line">git init</span><br><span class="line">git remote add -f origin &lt;repo-url&gt;</span><br></pre></td></tr></table></figure></li><li>在 <code>Config</code> 中设置允许使用<code>Sparse Checkout</code>模式 none <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.sparsecheckout true</span><br></pre></td></tr></table></figure></li><li>在<code>.git/info/</code>目录下新建<code>sparse-checkout</code>文件（注意文件名不要错了），写入需要的文件（<strong>一行为一项</strong>） 如： none <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/source/tools/index.html</span><br><span class="line">/source/about</span><br></pre></td></tr></table></figure></li><li>以正常方式从服务器pull下来即可 none <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法三：利用-DownGit-工具"><a href="#方法三：利用-DownGit-工具" class="headerlink" title="方法三：利用 DownGit 工具"></a><a href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%88%A9%E7%94%A8-DownGit-%E5%B7%A5%E5%85%B7" title="方法三：利用 DownGit 工具"></a>方法三：利用 <a href="http://tool.mkblog.cn/downgit/#/home">DownGit</a> 工具</h3>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://th.bing.com/th/id/OIP.lEetUExVDCW3Oq0Yl-CtLwHaBl?pid=ImgDet&amp;rs=1&quot;/&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Base64编码原理解析</title>
    <link href="http://example.com/2021/11/20/base64/"/>
    <id>http://example.com/2021/11/20/base64/</id>
    <published>2021-11-20T04:21:16.000Z</published>
    <updated>2021-11-20T04:31:36.316Z</updated>
    
    <content type="html"><![CDATA[<p>在制作v2订阅链接时经常需要使用到base64编码</p><span id="more"></span><h1 id="1-Base64-是什么"><a href="#1-Base64-是什么" class="headerlink" title="1. Base64 是什么"></a><strong>1. Base64 是什么</strong></h1><p> Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 2^6=64，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 Base64 单元，即 3 个字节可由 4 个可打印字符来表示。</p><p> ——维基百科</p><p>它不是一种加解密技术，是一种简单的编解码技术。</p><p>Base64 常用于表示、传输、存储二进制数据，也可以用于将一些含有特殊字符的文本内容编码，以便传输。</p><p>比如：</p><ol><li><p>在电子邮件的传输中，Base64 可以用来将 binary 的字节序列，比如附件，编码成 ASCII 字节序列；</p></li><li><p>将一些体积不大的图片 Base64 编码后，直接内嵌到网页源码里；</p></li><li><p>将要传递给 HTTP 请求的参数做简单的转换，降低肉眼可读性；</p></li></ol><p> 注：用于 URL 的 Base64 非标准 Base64，是一种变种。</p><ol start="4"><li>网友们在论坛等公开场合习惯将邮箱地址 Base64 后再发出来，防止被爬虫抓取后发送垃圾邮件。</li></ol><h1 id="2-Base64-编码原理"><a href="#2-Base64-编码原理" class="headerlink" title="2. Base64 编码原理"></a><strong>2. Base64 编码原理</strong></h1><p>标准 Base64 里的 64 个可打印字符是 A-Za-z0-9+/，分别依次对应索引值 0-63。索引表如下：<br><img src="https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images/posts/java/base64-index.png"/><br>编码时，每 3 个字节一组，共 8bit*3=24bit，划分成 4 组，即每 6bit 代表一个编码后的索引值，划分如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images/posts/java/base64-split.png"/><br>这样可能不太直观，举个例子就容易理解了。比如我们对 cat 进行编码：<br><img src="https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images/posts/java/base64-example.jpeg"/><br>可以看到 cat 编码后变成了 Y2F0。</p><p>如果待编码内容的字节数不是 3 的整数倍，那需要进行一些额外的处理。</p><p>如果最后剩下 1 个字节，那么将补 4 个 0 位，编码成 2 个 Base64 字符，然后补两个 =：<br><img src="https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images/posts/java/base64-padding2.png"/><br>如果最后剩下 2 个字节，那么将补 2 个 0 位，编码成 3 个 Base64 字符，然后补一个 =：<br><img src="https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images/posts/java/base64-padding1.png"/></p><h1 id="3-实现一个简易的-Base64-编码器"><a href="#3-实现一个简易的-Base64-编码器" class="headerlink" title="3. 实现一个简易的 Base64 编码器"></a><strong>3. 实现一个简易的 Base64 编码器</strong></h1><p>讲完原理，我们就可以动手实现一个简易的标准 Base64 编码器了，以下是我参考 Java 8 的 java.util.Base64 乱写的一个 Java 版本，仅供参考，主要功能代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class CustomBase64Encoder &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 索引表</span><br><span class="line">     */</span><br><span class="line">    private static final char[] sBase64 = &#123;</span><br><span class="line">            &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;,</span><br><span class="line">            &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;,</span><br><span class="line">            &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;,</span><br><span class="line">            &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;,</span><br><span class="line">            &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;,</span><br><span class="line">            &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;,</span><br><span class="line">            &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;,</span><br><span class="line">            &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;+&#x27;, &#x27;/&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将 byte[] 进行 Base64 编码并返回字符串</span><br><span class="line">     * @param src 原文</span><br><span class="line">     * @return 编码后的字符串</span><br><span class="line">     */</span><br><span class="line">    public static String encode(byte[] src) &#123;</span><br><span class="line">        if (src == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byte[] dst = new byte[(src.length + 2) / 3 * 4];</span><br><span class="line"></span><br><span class="line">        int index = 0;</span><br><span class="line"></span><br><span class="line">        // 每次将 3 个字节编码为 4 个字节</span><br><span class="line">        for (int i = 0; i &lt; (src.length / 3 * 3); i += 3) &#123;</span><br><span class="line">            int bits = (src[i] &amp; 0xff) &lt;&lt; 16 | (src[i + 1] &amp; 0xff) &lt;&lt; 8 | (src[i + 2] &amp; 0xff);</span><br><span class="line">            dst[index++] = (byte) sBase64[(bits &gt;&gt;&gt; 18) &amp; 0x3f];</span><br><span class="line">            dst[index++] = (byte) sBase64[(bits &gt;&gt;&gt; 12) &amp; 0x3f];</span><br><span class="line">            dst[index++] = (byte) sBase64[(bits &gt;&gt;&gt; 6) &amp; 0x3f];</span><br><span class="line">            dst[index++] = (byte) sBase64[bits &amp; 0x3f];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 处理剩下的 1 个或 2 个字节</span><br><span class="line">        if (src.length % 3 == 1) &#123;</span><br><span class="line">            int bits = (src[src.length - 1] &amp; 0xff) &lt;&lt; 4;</span><br><span class="line">            dst[index++] = (byte) sBase64[(bits &gt;&gt;&gt; 6) &amp; 0x3f];</span><br><span class="line">            dst[index++] = (byte) sBase64[bits &amp; 0x3f];</span><br><span class="line">            dst[index++] = &#x27;=&#x27;;</span><br><span class="line">            dst[index] = &#x27;=&#x27;;</span><br><span class="line">        &#125; else if (src.length % 3 == 2) &#123;</span><br><span class="line">            int bits = (src[src.length - 2] &amp; 0xff) &lt;&lt; 10 | (src[src.length - 1] &amp; 0xff) &lt;&lt; 2;</span><br><span class="line">            dst[index++] = (byte) sBase64[(bits &gt;&gt;&gt; 12) &amp; 0x3f];</span><br><span class="line">            dst[index++] = (byte) sBase64[(bits &gt;&gt;&gt; 6) &amp; 0x3f];</span><br><span class="line">            dst[index++] = (byte) sBase64[bits &amp; 0x3f];</span><br><span class="line">            dst[index] = &#x27;=&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new String(dst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分源码我也上传到 GitHub 仓库 <a href="https://github.com/mzlogin/spring-practices">https://github.com/mzlogin/spring-practices</a> 的 base64test 工程里了</p><h1 id="4-其它知识点"><a href="#4-其它知识点" class="headerlink" title="4. 其它知识点"></a><strong>4. 其它知识点</strong></h1><h2 id="4-1-为什么有的编码结果带回车"><a href="#4-1-为什么有的编码结果带回车" class="headerlink" title="4.1 为什么有的编码结果带回车"></a><strong>4.1 为什么有的编码结果带回车</strong></h2><p>在电子邮件中，根据 RFC 822 规定，每 76 个字符需要加上一个回车换行，所以有些编码器实现，比如 sun.misc.BASE64Encoder.encode，是带回车的，还有 java.util.Base64.Encoder.RFC2045，是带回车换行的，每行 76 个字符。</p><h2 id="4-2-Base64-的变种"><a href="#4-2-Base64-的变种" class="headerlink" title="4.2 Base64 的变种"></a><strong>4.2 Base64 的变种</strong></h2><p>除了标准 Base64 之外，还有一些其它的 Base64 变种。</p><p>比如在 URL 的应用场景中，因为标准 Base64 索引表中的 / 和 + 会被 URLEncoder 转义成 %XX 形式，但 % 是 SQL 中的通配符，直接用于数据库操作会有问题。此时可以采用 URL Safe 的编码器，索引表中的 /+ 被换成 -_，比如 java.util.Base64.Encoder.RFC4648_URLSAFE 就是这样的实现。</p><h1 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5. 参考链接"></a><strong>5. 参考链接</strong></h1><p><a href="https://zh.wikipedia.org/zh-hans/Base64">https://zh.wikipedia.org/zh-hans/Base64</a><br><a href="https://www.liaoxuefeng.com/wiki/897692888725344/949441536192576">https://www.liaoxuefeng.com/wiki/897692888725344/949441536192576</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在制作v2订阅链接时经常需要使用到base64编码&lt;/p&gt;</summary>
    
    
    
    
    <category term="v2ray" scheme="http://example.com/tags/v2ray/"/>
    
  </entry>
  
  <entry>
    <title>CloudFlare 缓存全站</title>
    <link href="http://example.com/2021/11/19/CloudFlare-%E7%BC%93%E5%AD%98%E5%85%A8%E7%AB%99/"/>
    <id>http://example.com/2021/11/19/CloudFlare-%E7%BC%93%E5%AD%98%E5%85%A8%E7%AB%99/</id>
    <published>2021-11-18T16:43:31.000Z</published>
    <updated>2021-11-18T16:45:47.290Z</updated>
    
    <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/wdm1732418365/CDN/New%20folder/install-cloudflare-1.png"/>CloudFlare 默认只对静态资源进行缓存。动态资源是默认不缓存的。如果你的内容基本是静态的或者不在意实时更新的话，可以使用 CloudFlare 的页面规则设置缓存所有内容。免费用户可以设置 3 条页面规则，Pro 用户可以使用 30 条规则。<span id="more"></span><img src="https://cdn.jsdelivr.net/gh/wdm1732418365/CDN/New%20folder/Snipaste_2021-10-29_19-07-33.png"/>如果要全域都走这条规则的话，就使用 * 表示全部，比如 *.ednovas.xyz/* 就是代表所有的 ednovas.xyz 前缀后缀的域名都要走这个规则<img src="https://cdn.jsdelivr.net/gh/wdm1732418365/CDN/New%20folder/Snipaste_2021-10-29_19-08-52.png"/>还可以加上一条 Edge Cache TTL，此项为 cloudflare 多久去检查你的服务器并更新<img src="https://cdn.jsdelivr.net/gh/wdm1732418365/CDN/New%20folder/Snipaste_2021-10-29_19-09-59.png"/>如果有的时候进不去后台，可以设置个 Cache Level 的 bypass 规则，并且设置其为置顶规则<img src="https://cdn.jsdelivr.net/gh/wdm1732418365/CDN/New%20folder/Snipaste_2021-10-29_19-13-18.png"/>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wdm1732418365/CDN/New%20folder/install-cloudflare-1.png&quot;/&gt;
CloudFlare 默认只对静态资源进行缓存。动态资源是默认不缓存的。如果你的内容基本是静态的或者不在意实时更新的话，可以使用 CloudFlare 的页面规则设置缓存所有内容。免费用户可以设置 3 条页面规则，Pro 用户可以使用 30 条规则。</summary>
    
    
    
    
    <category term="cloudflare" scheme="http://example.com/tags/cloudflare/"/>
    
  </entry>
  
  <entry>
    <title>在 Windows11 中安装 WSA (安卓子系统)</title>
    <link href="http://example.com/2021/11/19/wsa/"/>
    <id>http://example.com/2021/11/19/wsa/</id>
    <published>2021-11-18T16:36:31.000Z</published>
    <updated>2021-11-18T16:42:51.420Z</updated>
    
    <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/wdm1732418365/CDN/New%20folder/Windows-11-android-sideloading.webp"/><span id="more"></span>首先你得打开 windows 里面的功能，在 windows 菜单里面搜索启用.... 功能然后打开里面的这两个功能<img src="https://cdn.jsdelivr.net/gh/IsaacWangTT/jsdelivr@fbd84daf694bc3c341f4a67c387fde02e92fc5a6/2021/10/23/fc239b9e839fce2255a2c5a3d58f57ca.png"/>重启之后下载需要的包商店下载链接 https://www.microsoft.com/store/productId/9P3395VX91NR安装包抓包地址 https://store.rg-adguard.net/在抓包地址右边选择 Slow 通道 (因为 Slow 通道对应的是 Beta 通道，其他 Fast,RP,Retail 分别对应 Dev, 预览，正式版)然后在地址栏里面输入商店下载地址<img src="https://cdn.jsdelivr.net/gh/IsaacWangTT/jsdelivr@8dd2873eac46c72a2e068fc1e111bc36e7ac36ee/2021/10/23/6e17ce2332480b48c65701599e6f129c.png"/>找到最下面的那个最大的包，我这里名字为 "MicrosoftCorporationII.WindowsSubsystemForAndroid_1.7.32815.0_neutral_~_8wekyb3d8bbwe.msixbundle"如果版本更新可能会变，不过都差不多，把它下载下来如果你双击它，你会发现无法安装这个时候我们需要用管理员运行 Powershell 来安装win+X 运行 Powershell<img src="https://cdn.jsdelivr.net/gh/IsaacWangTT/jsdelivr@d5c10c25afb416a0c37e06b0c4a330497c48d9ad/2021/10/23/de4a05fddc9621828c3f8b7c63023d81.png"/>在里面输入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-appxpackage &quot;这里填你下载的安装包的绝对路径&quot;</span><br></pre></td></tr></table></figure>比如我的就是<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-appxpackage &quot;D:\Downloads\Microsoft Edge\MicrosoftCorporationII.WindowsSubsystemForAndroid_1.7.32815.0_neutral___8wekyb3d8bbwe.Msixbundle&quot;</span><br></pre></td></tr></table></figure>回车执行然后就可以 enjoy 了<img src="https://cdn.jsdelivr.net/gh/IsaacWangTT/jsdelivr@4bee2cfec873eb34502cd370422d9cbc94559b72/2021/10/23/36f79476f2ecd91ba609db80023925f9.png"/>很多小伙伴装了 WSA 都发现没有桌面，这就意味着你只能用 adb 来进行和子系统的交互十分的麻烦，这里我推荐一个工具，[秋之盒](https://www.atmb.top/)**我使用的是 canary 金丝雀版本**进入 WSA 界面打开开发人员模式启用它，进入管理开发人员设置<img src="https://cdn.jsdelivr.net/gh/IsaacWangTT/jsdelivr@578098c98de446dabdd6739571a5e9777e9afadf/2021/10/23/740ba46d103856a0a5575f8ba092f631.png"/>打开 usb 调试<p>回到 WSA 界面，刷新和复制 IP<br>进入秋之盒<br><img src="https://cdn.jsdelivr.net/gh/IsaacWangTT/jsdelivr@ac1923a448e632aee5e7b0147ee37a811b86a1b7/2021/10/23/35b60326e485e438db3e1d2c4c480306.png"/></p><p>在这里输入你复制的 IP</p><p>安装一个然后你就能对 WSA 做你想做的事情了，比如可以安装一个应用商店，我这里推荐大家安装一个酷安<br>听说有人在 wsa 里面成功安装了谷歌框架，大家也可以试试</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wdm1732418365/CDN/New%20folder/Windows-11-android-sideloading.webp&quot;/&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>青龙2.10+XDD-Plus+nvjdc短信验证登录对接xdd-plus</title>
    <link href="http://example.com/2021/11/15/qinglong/"/>
    <id>http://example.com/2021/11/15/qinglong/</id>
    <published>2021-11-15T10:55:42.000Z</published>
    <updated>2021-11-15T11:29:04.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a><strong>一、准备工作</strong></h1><p>1.一台电脑（手机也可以，自行找ssh链接工具）</p><p>2.购买服务器，并开放服务器端口，这里以阿里云服务器为例。其它服务器自行百度，这里就不过多叙述。</p><img src="https://img-blog.csdnimg.cn/3a6a13ff5f794dcc9be281907f0f2c76.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCm57uV5Li25qKm5b2x,size_20,color_FFFFFF,t_70,g_se,x_16"/><span id="more"></span><img src="https://img-blog.csdnimg.cn/c2ae6ef788344755a1dfc3a37881e089.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCm57uV5Li25qKm5b2x,size_20,color_FFFFFF,t_70,g_se,x_16"/><p>3.连接服务器</p><h1 id="二、开始搭建"><a href="#二、开始搭建" class="headerlink" title="二、开始搭建"></a><strong>二、开始搭建</strong></h1><p><strong>1.安装docke并设置开机启动</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum check-update</span><br><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl status docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><h1 id="2-拉取青龙面板"><a href="#2-拉取青龙面板" class="headerlink" title="2.拉取青龙面板"></a><strong>2.拉取青龙面板</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit \</span><br><span class="line">  --name ql \</span><br><span class="line">  --hostname ql \</span><br><span class="line">  --restart always \</span><br><span class="line">  -p 5700:5700 \</span><br><span class="line">  -v $PWD/ql/config:/ql/config \</span><br><span class="line">  -v $PWD/ql/log:/ql/log \</span><br><span class="line">  -v $PWD/ql/db:/ql/db \</span><br><span class="line">  -v $PWD/ql/scripts:/ql/scripts \</span><br><span class="line">  -v $PWD/ql/jbot:/ql/jbot \</span><br><span class="line">  whyour/qinglong:latest</span><br></pre></td></tr></table></figure><p> 端口号可自己方法：</p><p>-p 5700:5700 端口号为5700</p><p>-p xxxx:5700 端口号为xxxx</p><p>注：改的端口号一定要在安全组中放行该端口，不然访问不到</p><h1 id="3-登录青龙面板"><a href="#3-登录青龙面板" class="headerlink" title="3.登录青龙面板"></a><strong>3.登录青龙面板</strong></h1><p>在浏览器中输入 服务器ip:端口号        端口号为上一步你自己设置的端口号</p><p>例如：123.123.123.123:5700</p><p>进入青龙面板的登陆页面，开始安装</p><h1 id="4-拉取定时任务脚本仓库"><a href="#4-拉取定时任务脚本仓库" class="headerlink" title="4.拉取定时任务脚本仓库"></a><strong>4.拉取定时任务脚本仓库</strong></h1><p>这里推荐两个仓库：</p><p>faker2仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://ghproxy.com/https://github.com/shufflewzc/faker2.git &quot;jd_|jx_|gua_|jddj_|getJDCookie&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|function|utils|sendNotify|ZooFaker_Necklace.js|JDJRValidator_|sign_graphics_validate|ql&quot;</span><br></pre></td></tr></table></figure><p>smiek2221仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://ghproxy.com/github.com/smiek2221/scripts.git &quot;jd_|gua_&quot; &quot;&quot; &quot;ZooFaker_Necklace.js|JDJRValidator_Pure.js|sign_graphics_validate.js&quot;</span><br></pre></td></tr></table></figure><p><strong>青龙面板相关依赖及部分脚本依赖不能偷懒，稍微等一等有点慢</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it QL bash -c &quot;npm install -g typescript&quot;</span><br><span class="line">docker exec -it QL bash -c &quot;npm install axios date-fns&quot;</span><br><span class="line">docker exec -it QL bash -c &quot;npm install crypto -g&quot;</span><br><span class="line">docker exec -it QL bash -c &quot;npm install jsdom&quot;</span><br><span class="line">docker exec -it QL bash -c &quot;npm install png-js&quot;</span><br><span class="line">docker exec -it QL bash -c &quot;npm install -g npm&quot;</span><br><span class="line">docker exec -it QL bash -c &quot;pnpm i png-js&quot;</span><br><span class="line">docker exec -it QL bash -c &quot;pip3 install requests&quot;</span><br><span class="line">docker exec -it QL bash -c &quot;apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev &amp;&amp; cd scripts &amp;&amp; npm install canvas --build-from-source&quot;</span><br><span class="line">docker exec -it QL bash -c &quot;apk add python3 zlib-dev gcc jpeg-dev python3-dev musl-dev freetype-dev&quot;</span><br><span class="line">docker exec -it QL bash -c &quot;cd /ql/scripts/ &amp;&amp; apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev &amp;&amp; npm i &amp;&amp; npm i -S ts-node typescript @types/node date-fns axios png-js canvas --build-from-source&quot;</span><br></pre></td></tr></table></figure><h1 id="5-应用设置配置"><a href="#5-应用设置配置" class="headerlink" title="5.应用设置配置"></a><strong>5.应用设置配置</strong></h1><p>为下一步的xdd-plus对接青龙做出准备</p><h1 id="6-搭建xdd-plus所需环境"><a href="#6-搭建xdd-plus所需环境" class="headerlink" title="6.搭建xdd-plus所需环境"></a><strong>6.搭建xdd-plus所需环境</strong></h1><pre><code> 6.1安装gcc      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>6.2下载go安装包 ，这里我们安装到usr/local目录 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local &amp;&amp; wget https://golang.google.cn/dl/go1.16.7.linux-amd64.tar.gz -O go1.16.7.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>6.3解压go安装包 tar -xvzf go1.16.7.linux-amd64.tar.gz6.4手动设置环境变量路径/etc/profile <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on</span><br><span class="line">export GOPROXY=https://goproxy.cn</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/usr/local/go/path</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure> 复制上方代码添加到profile文件末尾6.5执行source <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>6.6检测一下看看有没有安装成功 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure>6.7安装git <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br><span class="line"> </span><br><span class="line"> rpm -ivh epel-release-latest-7.noarch.rpm</span><br><span class="line"> </span><br><span class="line">  yum install -y git</span><br></pre></td></tr></table></figure></code></pre><h1 id="7-安装xdd-plus"><a href="#7-安装xdd-plus" class="headerlink" title="7.安装xdd-plus"></a><strong>7.安装xdd-plus</strong></h1><pre><code>    7.1拉取xdd-plus的库    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~ &amp;&amp; git clone https://ghproxy.com/https://github.com/764763903a/xdd-plus.git</span><br></pre></td></tr></table></figure>    7.2编译xdd     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd xdd-plus</span><br><span class="line">go build</span><br></pre></td></tr></table></figure>    7.3给与xdd最高权限     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 xdd</span><br></pre></td></tr></table></figure>    7.4运行xdd（要确保你在xdd-plus目录下）     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xdd</span><br></pre></td></tr></table></figure>     等程序跑个半分钟Ctrl+c退出    7.5WinSCP中手动修改root/xdd-plus/conf/config.yaml文件</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">mode: parallel  #模式 balance(均衡模式)、parallel(平行模式)</span><br><span class="line">containers:</span><br><span class="line">  - address: http://123.123.123.123:5700 #这里是你青龙面板的地址</span><br><span class="line">    username: 青龙面板的账号 #登陆青龙面板的账号</span><br><span class="line">    password: 青龙面板的密码 #登录青龙面板的密码</span><br><span class="line">    cid: Client ID #刚刚在青龙面板获取到的Client ID</span><br><span class="line">    secret: Client Secret #刚刚在青龙面板获取到的Client Secret</span><br><span class="line">    weigth: 1 #权重 balance模式下权重越高分得的ck越多，默认1</span><br><span class="line">    mode: parallel #模式 balance(均衡模式)、parallel(平行模式)</span><br><span class="line">    limit: 9999 #限制容器ck数目</span><br><span class="line">AtTime: 8 #填写1-12之间的数  填错自负默认为10  10点容易出现高峰超时。</span><br><span class="line">IsHelp: true  #填写true或者false  false</span><br><span class="line">IsOldV4: #填写true或者false  false是否新版或者旧版V4</span><br><span class="line">Wskey: true # 填空默认禁用wskey转换 需要的填true</span><br><span class="line">IsAddFriend: #填写true或者false  false</span><br><span class="line">Lim: #填写1-N 代表限制次数</span><br><span class="line">Tyt: #填写1-N 代表推一推需要的互助值，默认为8</span><br><span class="line">Later: #延时防止黑IP自己设置 默认60 不怕黑的改为1即可 单位是秒</span><br><span class="line">ApiToken: #nvjdc短信接入token参数，自己设置</span><br><span class="line">theme: /root/xdd-plus/theme/admin.html  #自定义主题，支持本地、网络路径 </span><br><span class="line">static: ./static #静态文件 便于自定义二维码页面时，引入css、js等文件</span><br><span class="line">master: #xdd-plus后台密码，并从井号开始把这一段文字全部删除</span><br><span class="line">database: /root/xdd-plus/.xdd.db </span><br><span class="line">qywx_key: #企业微信推送key</span><br><span class="line">daily_push: #定时任务</span><br><span class="line">resident: #均衡模式下所有容器共同的账号pin，有多个用&#x27;&amp;&#x27;拼接。不建议填写。</span><br><span class="line">user_agent:</span><br><span class="line">telegram_bot_token:</span><br><span class="line">telegram_user_id:</span><br><span class="line">TGURL: #填写TG代理地址参考https://www.kejiwanjia.com/server/5221.html#3worker</span><br><span class="line">qquid: 管理员QQ #接收通知的qq号，管理员QQ号码</span><br><span class="line">qqgid: QQ群号 #监听的群</span><br><span class="line">qbot_public_mode: true #qq机器人群聊模式，默认私聊模式</span><br><span class="line">default_priority: #新用户默认优先级</span><br><span class="line">no_ghproxy: true #更新资源是否不使用代理</span><br><span class="line">daily_asset_push_cron: 0 21 * * * #日常资产推送时间 可以不填</span><br><span class="line">repos:</span><br><span class="line">  - git: https://github.com/shufflewzc/faker2.git</span><br></pre></td></tr></table></figure><p>修改完之后Ctrl+s保存文件退出，回到命令行在次运行上一步7.4</p><p>出现二维码，扫码绑定你的机器人qq，等一会后向你的机器人发消息测试。</p><p>7.6然后Ctrl+c，为防止机器人被杀死我们后台挂机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xdd -d</span><br></pre></td></tr></table></figure><p> 我们的xdd-plus配置到此结束</p><h1 id="8-nvjdc短信验证登录对接xdd-plus"><a href="#8-nvjdc短信验证登录对接xdd-plus" class="headerlink" title="8.nvjdc短信验证登录对接xdd-plus"></a><strong>8.nvjdc短信验证登录对接xdd-plus</strong></h1><pre><code>     8.1先cd回根目录     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br></pre></td></tr></table></figure>    8.2首先安装unzip    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget unzip -y</span><br></pre></td></tr></table></figure>    8.3然后创建一个目录放配置以及chromium    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir nolanjdc &amp;&amp; cd nolanjdc</span><br></pre></td></tr></table></figure>     8.4拉取nvjdc对接xdd-plus专用的配置文件     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://cdn.jsdelivr.net/gh/yanyuwangluo/tuku@main/Config.json</span><br></pre></td></tr></table></figure>    8.5创建chromium文件夹并进入    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p  .local-chromium/Linux-884014 &amp;&amp; cd .local-chromium/Linux-884014</span><br></pre></td></tr></table></figure>    8.6下载chromium并删除chromium压缩包    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.huaweicloud.com/chromium-browser-snapshots/Linux_x64/884014/chrome-linux.zip &amp;&amp; unzip chrome-linux.zip  &amp;&amp;  rm  -f chrome-linux.zip</span><br></pre></td></tr></table></figure>     8.7回到刚刚创建的目录     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/nolanjdc</span><br></pre></td></tr></table></figure>    8.8拉取nvjdc项目镜像    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nolanhzy/nvjdc:1.0</span><br></pre></td></tr></table></figure>    8.9启动项目容器（5703就是你nvjdc的端口号）    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run   --name nolanjdc -p 5703:80 -d  -v  &quot;$(pwd)&quot;/Config.json:/app/Config/Config.json:ro \-v &quot;$(pwd)&quot;/.local-chromium:/app/.local-chromium  \-it --privileged=true  nolanhzy/nvjdc:1.0</span><br></pre></td></tr></table></figure>     8.10查看日志     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f nolanjdc</span><br></pre></td></tr></table></figure></code></pre><p>出现表示NETJDC started成功，然后Ctrl+c退出日志即可<br>         8.11修改nvjdc对接xdd-plus的配置文件</p><p>配置文件路径/root/nolanjdc/Config.json</p><p>编辑好后保存重启容器（修改配置文件后需要重启）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart nolanjdc</span><br></pre></td></tr></table></figure><p> 到这一步已经可以全部正常使用了 </p><p>后面做一些补充 </p><p>（可忽略）公告处可以公告处可通过html+css编写后转义替换添加更多功能，可进交流群。</p><p> 删除容器和镜像（后面的0.8是版本号跟随自己需求更改）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f nolanjdc &amp;&amp; docker rmi -f nolanhzy/nvjdc:1.0</span><br></pre></td></tr></table></figure><p>更新：更新前删除容器和镜像，然后继续执行8.7到8.10就好</p><p>卸载nvjdc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f nolanjdc &amp;&amp; docker rmi -f nolanhzy/nvjdc:1.0 &amp;&amp; rm -rf /root/nolanjdc </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、准备工作&quot;&gt;&lt;a href=&quot;#一、准备工作&quot; class=&quot;headerlink&quot; title=&quot;一、准备工作&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、准备工作&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;1.一台电脑（手机也可以，自行找ssh链接工具）&lt;/p&gt;
&lt;p&gt;2.购买服务器，并开放服务器端口，这里以阿里云服务器为例。其它服务器自行百度，这里就不过多叙述。&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/3a6a13ff5f794dcc9be281907f0f2c76.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCm57uV5Li25qKm5b2x,size_20,color_FFFFFF,t_70,g_se,x_16&quot;/&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用 Cloudflare Pages 托管静态网站</title>
    <link href="http://example.com/2021/10/31/Cloudflare-Pages/"/>
    <id>http://example.com/2021/10/31/Cloudflare-Pages/</id>
    <published>2021-10-31T09:45:34.000Z</published>
    <updated>2021-10-31T14:09:00.814Z</updated>
    
    <content type="html"><![CDATA[<img src="https://www.misterma.com/img-admin/uploads/16290271822437.png" />Cloudflare Pages 是一个静态网站托管服务，功能和 Github Pages 差不多，可以存放静态网页，还可以直接部署前端项目。如果你的网站只是静态博客或帮助文档的话，可以完全不需要购买服务器。Cloudflare 是全球最大的几个 CDN 服务商之一，速度应该会比 Github Pages 好一些，而且 Cloudflare Pages 一个账户可以创建多个网站。<span id="more"></span>最近我准备把 MWordStar 的帮助文档迁移到 Cloudflare Pages ，这样我的服务器就可以少管理一个网站，服务器出问题也不会影响主题帮助文档的访问。这里就简单写一下 Cloudflare Pages 的使用。<p>关联 Github 存储库<br>直接访问 <a href="https://pages.cloudflare.com/">https://pages.cloudflare.com/</a> ，没有账号的可以按照提示注册，有账号的可以直接登录。</p><p>Cloudflare Pages 的官网首页没有中文，但部署和设置页面是有中文的。登录后点击 创建项目 ，如下：<br><img src="https://www.misterma.com/img-admin/uploads/16290187581512.jpeg" alt="请输入图片描述" title="请输入图片描述" /><br>点击 连接 Github 账户 ：<br><img src="https://www.misterma.com/img-admin/uploads/16290189752064.jpeg" alt="请输入图片描述" title="请输入图片描述" /><br>这里会弹出 Github 的授权页面，选择 Install &amp; Authorize 允许 Cloudflare 访问 Github 账户，如下：<br><img src="https://www.misterma.com/img-admin/uploads/16290192466333.jpeg" alt="请输入图片描述" title="请输入图片描述" /><br>然后会显示 Github 存储库，也包括非公开的存储库，选择要部署的存储库，点击 开始设置 ：<br><img src="https://www.misterma.com/img-admin/uploads/16290194687453.jpeg" alt="请输入图片描述" title="请输入图片描述" /><br>设置构建命令和存放构建的页面的目录：<br><img src="https://www.misterma.com/img-admin/uploads/16290198291377.jpeg" alt="请输入图片描述" title="请输入图片描述" /><br>Cloudflare 克隆存储库后会自动执行 npm install 之类的命令下载所需的依赖，然后执行构建命令，然后把构建完成的文件放到网站目录。</p><p>点击 保存并部署 后 Cloudflare Pages 就会开始构建和部署，如下：<br><img src="https://www.misterma.com/img-admin/uploads/16290202797579.jpeg" alt="请输入图片描述" title="请输入图片描述" /><br>同时下方也会输出日志：<br><img src="https://www.misterma.com/img-admin/uploads/16290205378681.jpeg" alt="请输入图片描述" title="请输入图片描述" /><br>部署完成后点击 继续处理项目 就可以看到部署的网站了，如下：<br><img src="https://www.misterma.com/img-admin/uploads/16290207787046.jpeg" alt="请输入图片描述" title="请输入图片描述" /><br>默认的域名是 项目名称.pages.dev 。</p><p>设置域名<br>点击 自定义域 ：<br><img src="https://www.misterma.com/img-admin/uploads/16290210479376.jpeg" alt="请输入图片描述" title="请输入图片描述" /><br>输入要绑定的域名：<br><img src="https://www.misterma.com/img-admin/uploads/16290255602829.jpeg" alt="请输入图片描述" title="请输入图片描述" /><br>如果你用的是 Cloudflare 的 DNS 的话，Cloudflare可以一键设置 CNAME。如果不是的话就需要手动设置 CNAME，登录域名管理后台，添加一条 CNAME 指向默认的 pages.dev 域名。</p><p>我使用的是 Cloudflare 的 DNS，可以自动设置 CNAME：<br><img src="https://www.misterma.com/img-admin/uploads/16290256742490.jpeg" alt="请输入图片描述" title="请输入图片描述" /><br>设置完成后需要一段时间才会生效。</p><p>以上就是 Cloudflare Pages 的设置过程。免费的 Cloudflare Pages 账户每月最多只能构建 500 次，对于个人博客或小网站来说已经足够。</p><p>目前 Cloudflare Pages 只能通过 Github 来部署，不能直接上传 HTML。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://www.misterma.com/img-admin/uploads/16290271822437.png&quot; /&gt;
Cloudflare Pages 是一个静态网站托管服务，功能和 Github Pages 差不多，可以存放静态网页，还可以直接部署前端项目。如果你的网站只是静态博客或帮助文档的话，可以完全不需要购买服务器。Cloudflare 是全球最大的几个 CDN 服务商之一，速度应该会比 Github Pages 好一些，而且 Cloudflare Pages 一个账户可以创建多个网站。</summary>
    
    
    
    
    <category term="cloudflare" scheme="http://example.com/tags/cloudflare/"/>
    
  </entry>
  
  <entry>
    <title>CloudFlare Workers 反代任意网站和挂载单页代码</title>
    <link href="http://example.com/2021/10/31/CloudFlare-Workers/"/>
    <id>http://example.com/2021/10/31/CloudFlare-Workers/</id>
    <published>2021-10-30T16:44:10.000Z</published>
    <updated>2021-10-31T14:08:55.159Z</updated>
    
    <content type="html"><![CDATA[<img src="https://gitee.com/liuhao03/tuchuang/raw/master/202110192343045.png"/><strong>介绍</strong>CloudFlare Workers是一个支持jsproxy的无服务器函数服务，提供全球CDN支持，免费用户有每天10万请求额度；CloudFlare官网：<a href="https://dash.cloudflare.com">https://dash.cloudflare.com</a>记录下一些简单的使用方法，以后再陆续更新；<span id="more"></span><strong>Workers 单页挂载代码</strong><pre><code class="lang-php">addEventListener('fetch', event =&gt; &#123;  event.respondWith(handleRequest(event.request))&#125;)<p>// HTML代码<br>let html = <code>&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt;   &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;   &amp;lt;body&amp;gt;&amp;lt;div&amp;gt;Hello world!&amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;</code>;</p><p>/**</p><ul><li>Respond to the request</li><li>@param {Request} request</li><li>/<br>async function handleRequest(request) {<br>return new Response(html, {<br>  headers: {<pre><code>&#39;Content-Type&#39;: &#39;text/html; charset=UTF-8&#39;</code></pre>  },<br>  status: 200<br>})<br>}</code></pre><br><strong>Workers 反代任意网站</strong><pre><code class="lang-php">// Website you intended to retrieve for users.const upstream = 'sunpma.com'</li></ul><p>// Custom pathname for the upstream website.<br>const upstream_path = ‘/‘</p><p>// Website you intended to retrieve for users using mobile devices.<br>const upstream_mobile = ‘sunpma.com’</p><p>// Countries and regions where you wish to suspend your service.<br>const blocked_region = [‘KP’, ‘SY’, ‘PK’, ‘CU’]</p><p>// IP addresses which you wish to block from using your service.<br>const blocked_ip_address = [‘0.0.0.0’, ‘127.0.0.1’]</p><p>// Whether to use HTTPS protocol for upstream address.<br>const https = true</p><p>// Whether to disable cache.<br>const disable_cache = false</p><p>// Replace texts.<br>const replace_dict = &#123;<br>    ‘$upstream’: ‘$custom_domain’,<br>    ‘//sunpma.com’: ‘’<br>&#125;</p><p>addEventListener(‘fetch’, event =&gt; &#123;<br>    event.respondWith(fetchAndApply(event.request));<br>&#125;)</p><p>async function fetchAndApply(request) &#123;<br>    const region = request.headers.get(‘cf-ipcountry’).toUpperCase();<br>    const ip_address = request.headers.get(‘cf-connecting-ip’);<br>    const user_agent = request.headers.get(‘user-agent’);</p><pre><code>let response = null;let url = new URL(request.url);let url_hostname = url.hostname;if (https == true) &#123;    url.protocol = &#39;https:&#39;;&#125; else &#123;    url.protocol = &#39;http:&#39;;&#125;if (await device_status(user_agent)) &#123;    var upstream_domain = upstream;&#125; else &#123;    var upstream_domain = upstream_mobile;&#125;url.host = upstream_domain;if (url.pathname == &#39;/&#39;) &#123;    url.pathname = upstream_path;&#125; else &#123;    url.pathname = upstream_path + url.pathname;&#125;if (blocked_region.includes(region)) &#123;    response = new Response(&#39;Access denied: WorkersProxy is not available in your region yet.&#39;, &#123;        status: 403    &#125;);&#125; else if (blocked_ip_address.includes(ip_address)) &#123;    response = new Response(&#39;Access denied: Your IP address is blocked by WorkersProxy.&#39;, &#123;        status: 403    &#125;);&#125; else &#123;    let method = request.method;    let request_headers = request.headers;    let new_request_headers = new Headers(request_headers);    new_request_headers.set(&#39;Host&#39;, upstream_domain);    new_request_headers.set(&#39;Referer&#39;, url.protocol + &#39;//&#39; + url_hostname);    let original_response = await fetch(url.href, &#123;        method: method,        headers: new_request_headers    &#125;)    connection_upgrade = new_request_headers.get(&quot;Upgrade&quot;);    if (connection_upgrade &amp;amp;&amp;amp; connection_upgrade.toLowerCase() == &quot;websocket&quot;) &#123;        return original_response;    &#125;    let original_response_clone = original_response.clone();    let original_text = null;    let response_headers = original_response.headers;    let new_response_headers = new Headers(response_headers);    let status = original_response.status;        if (disable_cache) &#123;        new_response_headers.set(&#39;Cache-Control&#39;, &#39;no-store&#39;);    &#125;    new_response_headers.set(&#39;access-control-allow-origin&#39;, &#39;*&#39;);    new_response_headers.set(&#39;access-control-allow-credentials&#39;, true);    new_response_headers.delete(&#39;content-security-policy&#39;);    new_response_headers.delete(&#39;content-security-policy-report-only&#39;);    new_response_headers.delete(&#39;clear-site-data&#39;);        if (new_response_headers.get(&quot;x-pjax-url&quot;)) &#123;        new_response_headers.set(&quot;x-pjax-url&quot;, response_headers.get(&quot;x-pjax-url&quot;).replace(&quot;//&quot; + upstream_domain, &quot;//&quot; + url_hostname));    &#125;        const content_type = new_response_headers.get(&#39;content-type&#39;);    if (content_type != null &amp;amp;&amp;amp; content_type.includes(&#39;text/html&#39;) &amp;amp;&amp;amp; content_type.includes(&#39;UTF-8&#39;)) &#123;        original_text = await replace_response_text(original_response_clone, upstream_domain, url_hostname);    &#125; else &#123;        original_text = original_response_clone.body    &#125;        response = new Response(original_text, &#123;        status,        headers: new_response_headers    &#125;)&#125;return response;</code></pre><p>}</p><p>async function replace_response_text(response, upstream_domain, host_name) {<br>    let text = await response.text()</p><pre><code>var i, j;for (i in replace_dict) &#123;    j = replace_dict[i]    if (i == &#39;$upstream&#39;) &#123;        i = upstream_domain    &#125; else if (i == &#39;$custom_domain&#39;) &#123;        i = host_name    &#125;    if (j == &#39;$upstream&#39;) &#123;        j = upstream_domain    &#125; else if (j == &#39;$custom_domain&#39;) &#123;        j = host_name    &#125;    let re = new RegExp(i, &#39;g&#39;)    text = text.replace(re, j);&#125;return text;</code></pre><p>}</p><p>async function device_status(user_agent_info) {<br>    var agents = [“Android”, “iPhone”, “SymbianOS”, “Windows Phone”, “iPad”, “iPod”];<br>    var flag = true;<br>    for (var v = 0; v &lt; agents.length; v++) {<br>        if (user_agent_info.indexOf(agents[v]) &gt; 0) {<br>            flag = false;<br>            break;<br>        }<br>    }<br>    return flag;<br>}</code></pre><br>替换掉其中的sunpma.com为你需要反代的网址即可；</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://gitee.com/liuhao03/tuchuang/raw/master/202110192343045.png&quot;/&gt;
&lt;strong&gt;介绍&lt;/strong&gt;
CloudFlare Workers是一个支持jsproxy的无服务器函数服务，提供全球CDN支持，免费用户有每天10万请求额度；
CloudFlare官网：&lt;a href=&quot;https://dash.cloudflare.com&quot;&gt;https://dash.cloudflare.com&lt;/a&gt;
记录下一些简单的使用方法，以后再陆续更新；</summary>
    
    
    
    
    <category term="cloudflare" scheme="http://example.com/tags/cloudflare/"/>
    
  </entry>
  
  <entry>
    <title>V2RAY一键部署脚本</title>
    <link href="http://example.com/2021/10/31/V2RAY/"/>
    <id>http://example.com/2021/10/31/V2RAY/</id>
    <published>2021-10-30T16:43:10.000Z</published>
    <updated>2021-10-31T12:40:19.290Z</updated>
    
    <content type="html"><![CDATA[<img src="https://gitee.com/liuhao03/tuchuang/raw/master/202110192358637.png"/>此安装脚本除了可以安装V2以外，亦可以安装SS，MTP，Socks5，简单好用；<span id="more"></span><strong>一键安装命令：</strong>Debian/Ubuntu<pre><code class="lang-php">apt-get updateapt-get install curl -ybash &lt;(curl -s -L https://git.io/v2ray.sh)</code></pre>Centos<pre><code class="lang-php">yum updateyum install curl -ybash &lt;(curl -s -L https://git.io/v2ray.sh)</code></pre>根据提示选择需要的选项安装即可；管理面板命令：<ul>     <li>v2ray</li></ul><strong>安装过程</strong><pre><code class="lang-php"> 1. 安装<ol start="2"><li>卸载</li></ol><p>请选择 [1-2]:1</p><p>请选择 V2Ray 传输协议 [1-32]</p><ol><li>TCP</li><li>TCP_HTTP</li><li>WebSocket</li><li>WebSocket + TLS</li><li>HTTP/2</li><li>mKCP</li><li>mKCP_utp</li><li>mKCP_srtp</li><li>mKCP_wechat-video</li><li>mKCP_dtls</li><li>mKCP_wireguard</li><li>QUIC</li><li>QUIC_utp</li><li>QUIC_srtp</li><li>QUIC_wechat-video</li><li>QUIC_dtls</li><li>QUIC_wireguard</li><li>TCP_dynamicPort</li><li>TCP_HTTP_dynamicPort</li><li>WebSocket_dynamicPort</li><li>mKCP_dynamicPort</li><li>mKCP_utp_dynamicPort</li><li>mKCP_srtp_dynamicPort</li><li>mKCP_wechat-video_dynamicPort</li></ol><p> ….准备安装了咯..看看有毛有配置正确了…</p><p>———- 安装信息 ————-</p><p> V2Ray 传输协议 = TCP</p><p> V2Ray 端口 = 64057</p><p> 是否配置 Shadowsocks = 未配置</p><p>———- END ————-</p><p>按 Enter 回车键 继续….或按 Ctrl + C 取消.</code></pre><br><strong>安装结果</strong></p><pre><code class="lang-php">---------- V2Ray 配置信息 ------------- 地址 (Address) = xx.xx.xx.xx 端口 (Port) = 64057 用户ID (User ID / UUID) = 35b4eee6-d90b-4e9f-bab9-c1266f2ad8c0 额外ID (Alter Id) = 233 传输协议 (Network) = tcp 伪装类型 (header type) = none---------- END -------------提示: 输入 v2ray url 可生成 vmess URL 链接 / 输入 v2ray qr 可生成二维码链接</code></pre><p><strong>管理脚本</strong></p><pre><code class="lang-php">## V2Ray 版本: v4.21.3  /  V2Ray 状态: 正在运行 ##  1. 查看 V2Ray 配置  2. 修改 V2Ray 配置  3. 下载 V2Ray 配置 / 生成配置信息链接 / 生成二维码链接  4. 查看 Shadowsocks 配置 / 生成二维码链接  5. 修改 Shadowsocks 配置  6. 查看 MTProto 配置 / 修改 MTProto 配置  7. 查看 Socks5 配置 / 修改 Socks5 配置  8. 启动 / 停止 / 重启 / 查看日志  9. 更新 V2Ray / 更新 V2Ray 管理脚本 10. 卸载 V2Ray 11. 其他温馨提示...如果你不想执行选项...按 Ctrl + C 即可退出请选择菜单 [1-11]:</code></pre>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://gitee.com/liuhao03/tuchuang/raw/master/202110192358637.png&quot;/&gt;
此安装脚本除了可以安装V2以外，亦可以安装SS，MTP，Socks5，简单好用；</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>用 Vim 编辑 Markdown 时直接粘贴图片</title>
    <link href="http://example.com/2021/05/20/Vim-Markdown/"/>
    <id>http://example.com/2021/05/20/Vim-Markdown/</id>
    <published>2021-05-20T03:45:48.000Z</published>
    <updated>2021-11-20T07:05:32.327Z</updated>
    
    <content type="html"><![CDATA[<p>我习惯使用 Vim 编辑 Markdown 文件，一直存在一个痛点就是粘贴图片很不方便。</p><span id="more"></span><h1 id="前后对比"><a href="#前后对比" class="headerlink" title="前后对比"></a><strong>前后对比</strong></h1><p>我以前常用的操作流程：</p><ol><li>复制图片/截图；</li><li>在保存图片对话框里一层层点选保存路径，输入文件名保存；</li><li>回到 Vim 里，手动输入引用图片的表达式。<br>第 2 步和第 3 步是比较痛苦的，尤其是文件路径比较深的时候，可能要点选好几次。</li></ol><p>最近偶然发现的一个外国小伙写的插件 <a href="https://github.com/ferrine/md-img-paste.vim">md-img-paste.vim</a>，能比较好地解决这个问题。现在的操作流程：</p><ol><li>复制图片/截图；</li><li>在 Vim 里输入图片相对路径，自动保存图片并插入引用图片的表达式。</li></ol><p>注：也可以直接回车，会按默认规则生成文件名。</p><p>效果演示：<br><img src="https://cdn.jsdelivr.net/gh/mzlogin/blog-assets/md-img-paste-example.gif"/></p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h1><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h1><p>这个插件没有其它依赖，使用自己习惯的插件管理方式安装就好。</p><p>比如我使用 <a href="https://github.com/VundleVim/Vundle.vim">Vundle</a>，在 vimrc 里添加如下内容，然后 :so $MYVIMRC 再 :PluginInstall 就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plugin &#x27;ferrine/md-img-paste.vim&#x27;</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h1><p>插件没有给粘贴剪贴板里的图片的操作绑定默认快捷键，需要自己绑定一下，比如我是绑定到 &lt;leader&gt;i：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd FileType markdown nmap &lt;buffer&gt;&lt;silent&gt; &lt;leader&gt;i :call mdip#MarkdownClipboardImage()&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>另外还有两个可选配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:mdip_imgdir = &#x27;.&#x27;</span><br><span class="line">&quot; let g:mdip_imgname = &#x27;image&#x27;</span><br></pre></td></tr></table></figure><ol><li>g:mdip_imgdir 对应图片保存路径前缀。我设置为了 .，然后总是输入相对当前文件的路径；</li><li>g:mdip_imgname 对应图片保存时的缺省文件名前缀，即粘贴图片时，如果不输入文件名直接回车，将保存为 &lt;前缀&gt;_日期-时间.png 名称的文件。<br>我的完整 Vim 配置文件托管在 <a href="https://github.com/mzlogin/config-files/blob/master/_vimrc">GitHub</a>，供参考。</li></ol><p>It’s done, enjoy it.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我习惯使用 Vim 编辑 Markdown 文件，一直存在一个痛点就是粘贴图片很不方便。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MarkDown" scheme="http://example.com/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>Docker部署为知笔记（国内gitbook）</title>
    <link href="http://example.com/2021/04/12/wiznote/"/>
    <id>http://example.com/2021/04/12/wiznote/</id>
    <published>2021-04-12T07:47:49.000Z</published>
    <updated>2021-11-12T08:18:02.250Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.2002000.xyz/imgs/2021/06/fe66b9023ec35d9b.png" alt="请输入图片描述"></p><p><strong>软件特色</strong></p><ul><li>一键收集微信、网页、微博 保存碎片信息 批量导入文档</li><li>文字、清单、手写 图片、拍照、语音、附件 一次记录永久保存</li><li>轻量级图文编辑工具 内置Markdown功能 写出漂亮的文档</li><li>资料永久保存在云端 修改后的笔记会保存历史版本 无需担心资料丢失</li><li>群组、多级文件夹、标签 让资料井井有条</li><li>关键词全文搜索 快捷方式定位文件夹和笔记 快速找到所需资料<span id="more"></span></li></ul><p>  <strong>前言</strong><br>官网:<a href="https://www.wiz.cn/zh-cn/">WizNote</a></p><p>官方安装教程:<a href="https://www.wiz.cn/zh-cn/docker">WizNote</a></p><p><strong>安装</strong><br>安装Docker</p><p>curl -fsSL <a href="https://get.docker.com/">https://get.docker.com</a> -o get-docker.sh</p><p>sh get-docker.sh<br>启动为知笔记服务端<br>执行</p><p>cd ~<br>mkdir wizdata<br>然后执行</p><p>docker run –name wiz –restart=always -it -d -v  ~/wizdata:/wiz/storage -v  /etc/localtime:/etc/localtime -p 80:80 -p 9269:9269/udp  wiznote/wizserver<br>将其中的-p 80:80的一个80改为你想要的端口,例如-p 8080:80 或者改为-p 10003:80,这样下面的配置文件就不用改了</p><p>当然,如果你不想配置HTTPS而且本地没有其他HTTP服务器你可以直接梭哈</p><p>配置HTTPS<br>由于现在一直在用Apache,就只po出一个Apache的配置文件了</p><p>&lt;VirtualHost *:80&gt;<br>    ServerAdmin <a href="mailto:&#97;&#x64;&#x6d;&#x69;&#110;&#64;&#109;&#111;&#x65;&#99;&#46;&#116;&#x6f;&#112;">&#97;&#x64;&#x6d;&#x69;&#110;&#64;&#109;&#111;&#x65;&#99;&#46;&#116;&#x6f;&#112;</a><br>    DocumentRoot “/www/wwwroot/域名”<br>    ServerName 域名<br>    #errorDocument 404 /404.html<br>    ErrorLog “/www/wwwlogs/wiz.5777.tk-error_log”<br>    CustomLog “/www/wwwlogs/wiz.5777.tk-access_log” combined<br>    <Location /><br>    ProxyPass <a href="http://localhost:10003/">http://localhost:10003/</a><br>    ProxyPassReverse <a href="http://localhost:10003/">http://localhost:10003/</a><br>    </Location></p><pre><code>#DENY FILES &lt;Files ~ (\.user.ini|\.htaccess|\.git|\.svn|\.project|LICENSE|README.md)$&gt;   Order allow,deny   Deny from all&lt;/Files&gt;</code></pre></VirtualHost><VirtualHost *:443>    ServerAdmin admin@moec.top    DocumentRoot "/www/wwwroot/域名/"    ServerName 域名    #errorDocument 404 /404.html    ErrorLog "/www/wwwlogs/域名-error_log"    CustomLog "/www/wwwlogs/域名-access_log" combined <pre><code>&lt;Location /&gt;ProxyPass http://localhost:10003/ProxyPassReverse http://localhost:10003/&lt;/Location&gt;#SSLSSLEngine OnSSLCertificateFile /www/server/panel/vhost/cert/---/fullchain.pemSSLCertificateKeyFile /www/server/panel/vhost/cert/---/privkey.pemSSLCipherSuite EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5SSLProtocol All -SSLv2 -SSLv3 -TLSv1SSLHonorCipherOrder On#DENY FILES &lt;Files ~ (\.user.ini|\.htaccess|\.git|\.svn|\.project|LICENSE|README.md)$&gt;   Order allow,deny   Deny from all&lt;/Files&gt;</code></pre></VirtualHost>按照你的配置配置后,重载你的Apache即可<p>安装完成<br>访问你配置的域名即可</p><p>默认账号:密码 <a href="mailto:&#97;&#x64;&#109;&#x69;&#110;&#x40;&#x77;&#x69;&#122;&#x2e;&#99;&#x6e;">&#97;&#x64;&#109;&#x69;&#110;&#x40;&#x77;&#x69;&#122;&#x2e;&#99;&#x6e;</a>:123456<br><img src="https://img.2002000.xyz/imgs/2021/06/fe66b9023ec35d9b.png" alt="请输入图片描述"></p><p>然后点击头像,访问管理后台<br><img src="https://img.2002000.xyz/imgs/2021/06/cc0b16a6eb3d0ba3.png" alt="请输入图片描述"></p><p>访问用户管理即可更改管理员<br><img src="https://img.2002000.xyz/imgs/2021/06/99d22340ab592e6d.png" alt="请输入图片描述"></p><p>桌面客户端<br><a href="https://www.wiz.cn/zh-cn/download.html">桌面客户端</a></p><p><a href="https://www.wiz.cn/zh-cn/wiznote-lite">WizNote Lite (支持Markdown实时渲染)</a></p><p>客户端截图:<br><img src="https://img.2002000.xyz/imgs/2021/06/c9be9368435f9960.png" alt="请输入图片描述"></p><p>体验:</p><p>有一些BUG,不过能用.webp<br>如外链图片无法加载</p><p>更新<br>docker stop wiz<br>docker rm wiz<br>docker pull wiznote/wizserver:latest<br>备份<br>备份非常的简单,只需要备份~/wizdata这个文件夹即可</p><p>*@master-node:~/wizdata# ll<br>total 36<br>drwxr-xr-x  2 root  root  4096 Jun  6 08:30 config<br>drwxr-xr-x  3 root  root  4096 Jun  6 08:28 data_root<br>drwxrwxrwx 12 mysql mysql 4096 Jun  6 08:18 db<br>drwxrwxrwx  2 root  root  4096 Jun  6 08:23 index<br>drwxrwxrwx  3 root  root  4096 Jun  6 08:18 logs<br>drwxr-xr-x  3 root  root  4096 Jun  6 08:29 override_files<br>drwxr-xr-x  2 root  root  4096 Jun  6 08:46 wiz-abstract<br>drwxr-xr-x  2 root  root  4096 Jun  6 08:23 wiz-gather-dev<br>drwxr-xr-x  3 root  root  4096 Jun  6 08:46 wizserver-temp<br>里面包含了所有的数据</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.2002000.xyz/imgs/2021/06/fe66b9023ec35d9b.png&quot; alt=&quot;请输入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件特色&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一键收集微信、网页、微博 保存碎片信息 批量导入文档&lt;/li&gt;
&lt;li&gt;文字、清单、手写 图片、拍照、语音、附件 一次记录永久保存&lt;/li&gt;
&lt;li&gt;轻量级图文编辑工具 内置Markdown功能 写出漂亮的文档&lt;/li&gt;
&lt;li&gt;资料永久保存在云端 修改后的笔记会保存历史版本 无需担心资料丢失&lt;/li&gt;
&lt;li&gt;群组、多级文件夹、标签 让资料井井有条&lt;/li&gt;
&lt;li&gt;关键词全文搜索 快捷方式定位文件夹和笔记 快速找到所需资料</summary>
    
    
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>使用 jsDelivr 免费加速 GitHub Pages 博客的静态资源</title>
    <link href="http://example.com/2021/03/20/jsDelivr/"/>
    <id>http://example.com/2021/03/20/jsDelivr/</id>
    <published>2021-03-20T03:51:24.000Z</published>
    <updated>2021-11-20T04:20:05.301Z</updated>
    
    <content type="html"><![CDATA[<p>挺久以前就有网友给我的 GitHub Pages 博客模板提 Issue，说希望能增加 CDN 用于加速静态资源的加载，由于懒，一直没有动。</p><span id="more"></span><p>最近偶尔要打开自己博客看下 Wiki 的时候，要等挺久，比较痛苦，碰巧昨天晚上看到这样一篇帖子：GitHub 图床的正确用法，通过 jsDelivr CDN 全球加速，感觉很适合我的需求场景，于是决定趁这几天休假将这个改造一下。</p><h1 id="先看效果"><a href="#先看效果" class="headerlink" title="先看效果"></a><strong>先看效果</strong></h1><p>以下改造前后的加载情况都是在 Edge 浏览器禁用缓存后录制的，录制时间段很接近，从本地访问两个 GitHub Pages 服务的原始响应速度应该类似。</p><h1 id="改造前加载"><a href="#改造前加载" class="headerlink" title="改造前加载"></a><strong>改造前加载</strong></h1><img src="https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images/posts/github/cdn-before.png"/>注：由于改造前没有保留加载图，所以这是截的一个使用相同模板的朋友的首页加载情况。<p>可以看到耗时最长的两个请求时间达到了 12 秒左右，而且很多资源的加载时间在 1 秒以上，页面完成加载时间长达 15 秒多……估计一般的访客是没这个耐心等待的。</p><h1 id="改造后加载"><a href="#改造后加载" class="headerlink" title="改造后加载"></a><strong>改造后加载</strong></h1><img src="https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images/posts/github/cdn-after.png"/>这样一对比效果还是很明显的。改造过后耗时最长的是两个没办法走 CDN 的请求，而走 CDN 的那些资源加载时间基本都没超过 60 毫秒，页面完成加载时间缩短到了 3 秒以内。<p>当然，因为页面自身还是在 GitHub Pages 托管，有时候首个请求还是会挺久才返回。</p><p>改造后的效果可以打开 <a href="https://mazhuang.org/">https://mazhuang.org</a> 体验。</p><h1 id="方案考虑"><a href="#方案考虑" class="headerlink" title="方案考虑"></a><strong>方案考虑</strong></h1><p>优化独立博客的加载速度有一些不同的思路，对应不同的方案：</p><ol><li>优化博客代码，精简需要加载的资源；</li><li>将博客部署到国内访问快的服务器上；</li><li>部署到国内的代码托管平台，比如 Gitee 和 Coding 等；</li><li>采用 CDN 加速；<br>其中 2 和 3 我不想考虑，还是期望只在 GitHub 上管理博客，所以 1 和 4 是优化方向，本文对应的就是 4 的部分。</li></ol><p>而采用 CDN 加速的方案，可以考虑</p><ol><li>将公共库改为直接引用公共 CDN 链接；</li><li>自己编写和修改的静态资源自己去托管在一个 CDN 服务上。</li></ol><p> 有一些 CDN 服务商提供一定的免费额度，可以按喜好选用，或者选择付费服务。这里我没有纠结，看完文首提到的那篇文章，去看了下 jsDelivr 的介绍后觉得靠谱：它原生支持使用 GitHub 项目里的资源，什么都不用配置，更重要的是免费，在国内有节点，而且速度还不错（官网上也把 works in China 作为一个卖点的），遂决定直接用它。</p><h1 id="jsDelivr-支持的-GitHub-资源的方式"><a href="#jsDelivr-支持的-GitHub-资源的方式" class="headerlink" title="jsDelivr 支持的 GitHub 资源的方式"></a><strong>jsDelivr 支持的 GitHub 资源的方式</strong></h1><p>jsDelivr 对 GitHub 的支持是作为重要特性来宣传的，官网的介绍链接：<a href="https://www.jsdelivr.com/features#gh">https://www.jsdelivr.com/features#gh</a> 以下是一些认为需要了解的知识的小结：</p><p>这里以我托管博客的 GitHub 仓库为例，地址是 <a href="https://github.com/mzlogin/mzlogin.github.io%EF%BC%8C%E9%82%A3%E5%AE%83%E9%87%8C%E9%9D%A2%E7%9A%84%E8%B5%84%E6%BA%90%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BB%A5">https://github.com/mzlogin/mzlogin.github.io，那它里面的资源可以直接以</a> <a href="https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io/">https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io/</a> + 仓库里的文件路径 来访问。</p><p>比如仓库里有一个 js 文件 assets/js/main.js，那么它可以用 CDN 链接 <a href="https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io/assets/js/main.js">https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io/assets/js/main.js</a> 来访问。</p><p>另外还支持一些高级用法，比如：</p><ol><li>指定 release 版本号/提交 sha1/分支名称，例如指定获取该仓库的名称为 1.2.0 或 v1.2.0 的 release 版本资源：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@1.2.0/assets/js/main.js</span><br></pre></td></tr></table></figure>如果指定版本为 1 或者 1.2，那它会自动匹配到这个范围内的最新版本号。</li></ol><p> 也可以不指定版本或者指定版本为 latest，这样总是使用最新版本的资源。</p><ol start="2"><li>压缩资源，在 js/css 文件后缀前面加上 .min：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@1.2.0/assets/js/main.min.js</span><br></pre></td></tr></table></figure></li><li>合并多个文件，用 combine/file1,file2,file3 格式的链接：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/combine/gh/mzlogin/mzlogin.github.io@1.2.0/assets/js/main.min.js,gh/mzlogin/mzlogin.github.io@1.2.0/assets/js/simple-jekyll-search.min.js</span><br></pre></td></tr></table></figure>压缩资源、合并文件的 CDN 链接在第一次有人访问时可能比较慢，后面再有人访问就快了。</li></ol><h2 id="其它知识点："><a href="#其它知识点：" class="headerlink" title="其它知识点："></a>其它知识点：</h2><ol><li>可以通过 <a href="https://cdn.jsdelivr.net/combine/gh/mzlogin/mzlogin.github.io[@">https://cdn.jsdelivr.net/combine/gh/mzlogin/mzlogin.github.io[@</a>&lt;版本号&gt;]/[&lt;文件夹&gt;/] 这样的路径浏览缓存文件列表；</li><li>可以访问 <a href="https://purge.jsdelivr.net/gh/mzlogin/mzlogin.github.io@1.2.0/assets/js/main.js">https://purge.jsdelivr.net/gh/mzlogin/mzlogin.github.io@1.2.0/assets/js/main.js</a> 来清除指定文件的缓存；（将引用的 CDN 链接里的 cdn 改成 purge 就是了）</li><li>可以访问 <a href="https://data.jsdelivr.com/v1/package/gh/mzlogin/mzlogin.github.io">https://data.jsdelivr.com/v1/package/gh/mzlogin/mzlogin.github.io</a> 来查看 CDN 上的 tags 和 versions 列表，更多数据接口参数参见 <a href="https://github.com/jsdelivr/data.jsdelivr.com%E3%80%82">https://github.com/jsdelivr/data.jsdelivr.com。</a></li></ol><h1 id="改造步骤"><a href="#改造步骤" class="headerlink" title="改造步骤"></a><strong>改造步骤</strong></h1><p>下面是记录具体改造博客模板的步骤：</p><p>在 _config.yml 文件中添加控制开关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 对 css 和 js 资源的 cdn 加速配置</span><br><span class="line">cdn:</span><br><span class="line">    jsdelivr:</span><br><span class="line">        enabled: true</span><br></pre></td></tr></table></figure><p>修改 _layouts 里的文件，给名为 assets_base_url 的变量赋值，用它来代表加载静态资源的根路径：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% assign assets_base_url = site.url %&#125;</span><br><span class="line">&#123;% if site.cdn.jsdelivr.enabled %&#125;</span><br><span class="line">    &#123;% assign assets_base_url = &quot;https://cdn.jsdelivr.net/gh/&quot; | append: site.repository | append: &#x27;@master&#x27; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><br>修改以前直接用  拼接的静态资源引用链接，替换为 ，比如 _includes/header.html 里：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; site.url &#125;&#125;/assets/css/posts/index.css&quot;&gt;</span><br><span class="line">+ &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; assets_base_url &#125;&#125;/assets/css/posts/index.css&quot;&gt;</span><br></pre></td></tr></table></figure><br>这样万一哪天 CDN 出了点什么状况，我们也可以很方便地通过一个开关就切回自已的资源链接恢复服务。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;挺久以前就有网友给我的 GitHub Pages 博客模板提 Issue，说希望能增加 CDN 用于加速静态资源的加载，由于懒，一直没有动。&lt;/p&gt;</summary>
    
    
    
    
    <category term="jsDelivr" scheme="http://example.com/tags/jsDelivr/"/>
    
  </entry>
  
  <entry>
    <title>使用 jsDelivr 免费加速 GitHub Pages 博客的静态资源（二）</title>
    <link href="http://example.com/2021/03/10/jsDelivr-2/"/>
    <id>http://example.com/2021/03/10/jsDelivr-2/</id>
    <published>2021-03-10T04:13:47.000Z</published>
    <updated>2021-11-20T04:20:14.298Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇 使用 jsDelivr 免费加速 GitHub Pages 博客的静态资源，在那之后，又陆续想到并实施了几点利用 jsDelivr 进一步加速静态资源加载的措施，新起一篇作为记录和分享。</p><span id="more"></span><p>继上一轮改造过后，比较拖页面加载速度的主要有三点：</p><ol><li>页面首个请求响应时间；</li><li>图片资源加载时间；</li><li>站内搜索引用的 JSON 资源加载时间。</li></ol><p>第 1 点在页面仍然托管在 GitHub Pages 的前提下，似乎没有什么好办法能产生质的飞跃；本篇主要改善了第 2 点和第 3 点。</p><h1 id="0x01-图片资源加速"><a href="#0x01-图片资源加速" class="headerlink" title="0x01 图片资源加速"></a><strong>0x01 图片资源加速</strong></h1><p>这里所说的图片主要是指文章里引用的图片。</p><p>我一直将图片放在博客源码根目录的 images 文件夹下，引用图片的习惯写法是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![after use cdn](/images/posts/github/cdn-after.png)</span><br></pre></td></tr></table></figure><p>如果想将这个图片地址替换为 jsDelivr 的地址，需要做的就是将 /images 替换为 <a href="https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images">https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images</a></p><p>一处一处替换行不行？当然也行，但后面写新文章时要引用图片，还得手动写这一长串，不方便；万一 jsDeliver 出状况，也不好一键切换回来。有没有一劳永逸的方法？当然也有，我们从 Jekyll 的 layout 机制来想办法。</p><p>Jekyll 的 layout 可以理解为页面模板，它是可以继承的，比如我的博客的所有页面模板有一个共同的祖先模板 _layouts/default.html，模板里可以使用 Liquid 语法对内容进行处理，我们可以利用这一点，来自动完成批量替换的工作。</p><p>关键代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% assign assets_base_url = site.url %&#125;</span><br><span class="line">&#123;% if site.cdn.jsdelivr.enabled %&#125;</span><br><span class="line">&#123;% assign assets_base_url = &quot;https://cdn.jsdelivr.net/gh/&quot; | append: site.repository | append: &#x27;@master&#x27; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% assign assets_images_url = &#x27;src=&quot;&#x27; | append: assets_base_url | append: &quot;/images&quot; %&#125;</span><br><span class="line">&#123;% include header.html %&#125;</span><br><span class="line">    &#123;&#123; content | replace: &#x27;src=&quot;/images&#x27;, assets_images_url &#125;&#125;</span><br><span class="line">&#123;% include footer.html %&#125;</span><br></pre></td></tr></table></figure><p>大意就是，如果打开了启用 jsDelivr 加速的开关，就将 content 里的 src=”/images” 替换为 src=”<a href="https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images&quot;%EF%BC%8C%E5%90%A6%E5%88%99%E6%9B%BF%E6%8D%A2%E4%B8%BA">https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images&quot;，否则替换为</a> src=”<a href="https://mazhuang.org/images&quot;">https://mazhuang.org/images&quot;</a></p><p>以上便达成了我们的目的</p><h1 id="0x02-站内搜索引用的-JSON-资源加速"><a href="#0x02-站内搜索引用的-JSON-资源加速" class="headerlink" title="0x02 站内搜索引用的 JSON 资源加速"></a><strong>0x02 站内搜索引用的 JSON 资源加速</strong></h1><p>我是使用 <a href="https://github.com/christian-fei/Simple-Jekyll-Search">Simple-Jekyll-Search</a> 这个 JavaScript 库来实现站内搜索的，它的搜索数据是来自一个动态生成的 JSON 文件。</p><p>这个 JSON 文件编译前长这样：</p><p><a href="https://github.com/mzlogin/mzlogin.github.io/blob/master/assets/search_data.json">https://github.com/mzlogin/mzlogin.github.io/blob/master/assets/search_data.json</a></p><p>Jekyll 编译后长这样：</p><p><a href="https://mazhuang.org/assets/search_data.json">https://mazhuang.org/assets/search_data.json</a></p><p>这样的资源是没有办法直接通过替换网址来用 jsDelivr 加速的，因为 jsDelivr 上缓存的是编译前的文件，而我们需要的是编译后的。</p><p>那我们就想办法：</p><p>将博客源码编译；<br>将编译结果保存到另一个分支；<br>通过 jsDelivr 引用新分支上的这个文件。<br>这些步骤可以通过 GitHub 去年推出的新特性 <a href="https://github.com/features/actions">Actions</a> 来完成，在我们每一次向博客源码仓库 push 代码时自动触发。</p><p>关键步骤如下：</p><ol><li>在 GitHub 新建一个 Personal access Token：</li></ol><p> Settings –&gt; Developer settings –&gt; Personal access tokens –&gt; Generate new token –&gt; 填写 note，勾选 public_repo，生成之后复制 token 值备用。</p><ol start="2"><li><p>在博客源码仓库的 Settings –&gt; Secrets –&gt; New secret，Name 填 ACCESS_TOKEN，Value 填第 1 步里复制的 token 值；</p></li><li><p>在博客源码根目录下新建文件 .github/workflows/ci.yml，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">name: Build and Deploy</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: [ master ]</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build-and-deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - name: Checkout</span><br><span class="line">        uses: actions/checkout@v2.3.1</span><br><span class="line">        with: </span><br><span class="line">          persist-credentials: false</span><br><span class="line"></span><br><span class="line">      - name: Set Ruby 2.7</span><br><span class="line">        uses: actions/setup-ruby@v1</span><br><span class="line">        with:</span><br><span class="line">          ruby-version: 2.7</span><br><span class="line"></span><br><span class="line">      - name: Install and Build</span><br><span class="line">        run: |</span><br><span class="line">          gem install bundler</span><br><span class="line">          bundle install</span><br><span class="line">          bundle exec jekyll build</span><br><span class="line">           </span><br><span class="line">      - name: Deploy</span><br><span class="line">        uses: JamesIves/github-pages-deploy-action@3.6.2</span><br><span class="line">        with:</span><br><span class="line">          ACCESS_TOKEN: $</span><br><span class="line">          BRANCH: built</span><br><span class="line">          FOLDER: _site</span><br><span class="line">          CLEAN: true</span><br></pre></td></tr></table></figure><p>大意就是在向 master 分支 push 代码时，自动执行 checkout、初始化 ruby 环境、安装 Jekyll 并编译博客源码的工作，最后将编译生成的 _site 目录里的内容推送到 built 分支。对 GitHub Actions 感兴趣的同学可以自行参考官方说明学习</p></li><li><p>修改引用 JSON 文件的地方，比如我的 _includes/sidebar-search.html 里的写法由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json: &#x27;https://mazhuang.org/assets/search_data.json&#x27;,</span><br></pre></td></tr></table></figure><p>改为了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if site.cdn.jsdelivr.enabled and site.url contains &#x27;mazhuang.org&#x27; %&#125;</span><br><span class="line">  json: &#x27;https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@built/assets/search_data.json&#x27;,</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">  json: &#x27;&#123;&#123; site.url &#125;&#125;/assets/search_data.json&#x27;,</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>将以上更改推送到源码仓库，等待处理完成即可。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前写过一篇 使用 jsDelivr 免费加速 GitHub Pages 博客的静态资源，在那之后，又陆续想到并实施了几点利用 jsDelivr 进一步加速静态资源加载的措施，新起一篇作为记录和分享。&lt;/p&gt;</summary>
    
    
    
    
    <category term="jsDelivr" scheme="http://example.com/tags/jsDelivr/"/>
    
  </entry>
  
  <entry>
    <title>B2+CF+ShareX,实现无成本图床和便捷上传</title>
    <link href="http://example.com/2021/02/02/shareX/"/>
    <id>http://example.com/2021/02/02/shareX/</id>
    <published>2021-02-02T13:51:26.000Z</published>
    <updated>2021-11-02T13:53:42.373Z</updated>
    
    <content type="html"><![CDATA[<h1 class="wp-block-zibllblock-biaoti title-theme" id="wznav_0">准备</h1>1.一个cloudflare账号 https://dash.cloudflare.com/2.一个B2账号 https://www.backblaze.com/b2/cloud-storage.html3.windows软件ShareX<span id="more"></span><h1 class="wp-block-zibllblock-biaoti title-theme" id="wznav_1">步骤</h1>1.注册B2账号,点击进入B2 Cloud Storage,点击Buckets创建一个BUcket,设为public,并上传一个图片,记录下下图要用的域名<figure class="wp-block-image size-large"><img src="https://dlcu.cf/yymqCaPBK1.png" data-src="https://dlcu.cf/yymqCaPBK1.png" alt="" class=" lazyloaded" /></figure>2.点击App keys,添加一个新的key,bucket就选你刚创建的那个,记录下你的密钥,之后要在ShareX中用<figure class="wp-block-image size-large"><img src="https://dlcu.cf/lq4iZxMbyV.png" data-src="https://dlcu.cf/lq4iZxMbyV.png" alt="" class=" lazyloaded" /></figure>3.打开cf,cname一下上图要记的域名,小云朵点亮<figure class="wp-block-image size-large"><img src="https://dlcu.cf/zZ9ctKUmmD.png" data-src="https://dlcu.cf/zZ9ctKUmmD.png" alt="" class=" lazyloaded" /></figure>4.加一条页面缓存规则.<figure class="wp-block-image size-large"><img src="https://dlcu.cf/MzfvOqqD3w.png" data-src="https://dlcu.cf/MzfvOqqD3w.png" alt="" class=" lazyloaded" /></figure>5.创建一个workers,粘贴下列代码,记得b2domain和bucket的值改成自己的<div class="enlighter-default enlighter-v-standard enlighter-t-bootstrap4 enlighter-hover enlighter-linenumbers enlighter-overflow-scroll"><div class="enlighter"><div class=""><div><span class="enlighter-s0">'use strict'</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">const b2Domain = </span><span class="enlighter-s0">'img.domain.com'</span><span class="enlighter-text">;</span><span class="enlighter-c0"> // configure this as per instructions above</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">const b2Bucket = </span><span class="enlighter-s0">'bucket-name'</span><span class="enlighter-text">;</span><span class="enlighter-c0"> // configure this as per instructions above</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">const b2UrlPath = `/file/$</span><span class="enlighter-g1">{</span><span class="enlighter-text">b2Bucket</span><span class="enlighter-g1">}</span><span class="enlighter-text">/`;</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-m0">addEventListener</span><span class="enlighter-g1">(</span><span class="enlighter-s0">'fetch'</span><span class="enlighter-text">, event =</span><span class="enlighter-g1">&gt;</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-k1">return</span><span class="enlighter-text"> event.</span><span class="enlighter-m3">respondWith</span><span class="enlighter-g1">(</span><span class="enlighter-m0">fileReq</span><span class="enlighter-g1">(</span><span class="enlighter-text">event</span><span class="enlighter-g1">))</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-g1">})</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-c0"></span></div></div><div class=""><div><span class="enlighter-c0">// define the file extensions we wish to add basic access control headers to</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">const corsFileTypes = </span><span class="enlighter-g1">[</span><span class="enlighter-s0">'png'</span><span class="enlighter-text">, </span><span class="enlighter-s0">'jpg'</span><span class="enlighter-text">, </span><span class="enlighter-s0">'gif'</span><span class="enlighter-text">, </span><span class="enlighter-s0">'jpeg'</span><span class="enlighter-text">, </span><span class="enlighter-s0">'webp'</span><span class="enlighter-g1">]</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-c0"></span></div></div><div class=""><div><span class="enlighter-c0">// backblaze returns some additional headers that are useful for debugging, but unnecessary in production. We can remove these to save some size</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">const removeHeaders = </span><span class="enlighter-g1">[</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-s0">'x-bz-content-sha1'</span><span class="enlighter-text">,</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-s0">'x-bz-file-id'</span><span class="enlighter-text">,</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-s0">'x-bz-file-name'</span><span class="enlighter-text">,</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-s0">'x-bz-info-src_last_modified_millis'</span><span class="enlighter-text">,</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-s0">'X-Bz-Upload-Timestamp'</span><span class="enlighter-text">,</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-s0">'Expires'</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-g1">]</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">const expiration = </span><span class="enlighter-n1">31536000</span><span class="enlighter-text">;</span><span class="enlighter-c0"> // override browser cache for images - 1 year</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-c0"></span></div></div><div class=""><div><span class="enlighter-c0">// define a function we can re-use to fix headers</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">const fixHeaders = </span><span class="enlighter-k1">function</span><span class="enlighter-g1">(</span><span class="enlighter-text">url, status, headers</span><span class="enlighter-g1">){</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> let newHdrs = </span><span class="enlighter-k1">new</span><span class="enlighter-text"> </span><span class="enlighter-m0">Headers</span><span class="enlighter-g1">(</span><span class="enlighter-text">headers</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-c0"> // add basic cors headers for images</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-k1">if</span><span class="enlighter-g1">(</span><span class="enlighter-text">corsFileTypes.</span><span class="enlighter-m3">includes</span><span class="enlighter-g1">(</span><span class="enlighter-text">url.</span><span class="enlighter-m3">pathname</span><span class="enlighter-text">.</span><span class="enlighter-m3">split</span><span class="enlighter-g1">(</span><span class="enlighter-s0">'.'</span><span class="enlighter-g1">)</span><span class="enlighter-text">.</span><span class="enlighter-m3">pop</span><span class="enlighter-g1">())){</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> newHdrs.</span><span class="enlighter-m3">set</span><span class="enlighter-g1">(</span><span class="enlighter-s0">'Access-Control-Allow-Origin'</span><span class="enlighter-text">, </span><span class="enlighter-s0">'*'</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-c0"> // override browser cache for files when 200</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-k1">if</span><span class="enlighter-g1">(</span><span class="enlighter-text">status === </span><span class="enlighter-n1">200</span><span class="enlighter-g1">){</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> newHdrs.</span><span class="enlighter-m3">set</span><span class="enlighter-g1">(</span><span class="enlighter-s0">'Cache-Control'</span><span class="enlighter-text">, </span><span class="enlighter-s0">"public, max-age="</span><span class="enlighter-text"> + expiration</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-g1">}</span><span class="enlighter-k1">else</span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-c0"> // only cache other things for 5 minutes</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> newHdrs.</span><span class="enlighter-m3">set</span><span class="enlighter-g1">(</span><span class="enlighter-s0">'Cache-Control'</span><span class="enlighter-text">, </span><span class="enlighter-s0">'public, max-age=300'</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-c0"> // set ETag for efficient caching where possible</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> const ETag = newHdrs.</span><span class="enlighter-m3">get</span><span class="enlighter-g1">(</span><span class="enlighter-s0">'x-bz-content-sha1'</span><span class="enlighter-g1">)</span><span class="enlighter-text"> </span><span class="enlighter-g0">||</span><span class="enlighter-text"> newHdrs.</span><span class="enlighter-m3">get</span><span class="enlighter-g1">(</span><span class="enlighter-s0">'x-bz-info-src_last_modified_millis'</span><span class="enlighter-g1">)</span><span class="enlighter-text"> </span><span class="enlighter-g0">||</span><span class="enlighter-text"> newHdrs.</span><span class="enlighter-m3">get</span><span class="enlighter-g1">(</span><span class="enlighter-s0">'x-bz-file-id'</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-k1">if</span><span class="enlighter-g1">(</span><span class="enlighter-text">ETag</span><span class="enlighter-g1">){</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> newHdrs.</span><span class="enlighter-m3">set</span><span class="enlighter-g1">(</span><span class="enlighter-s0">'ETag'</span><span class="enlighter-text">, ETag</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-c0"> // remove unnecessary headers</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> removeHeaders.</span><span class="enlighter-m3">forEach</span><span class="enlighter-g1">(</span><span class="enlighter-text">header =</span><span class="enlighter-g1">&gt;</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> newHdrs.</span><span class="enlighter-m3">delete</span><span class="enlighter-g1">(</span><span class="enlighter-text">header</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-g1">})</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-k1">return</span><span class="enlighter-text"> newHdrs;</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-g1">}</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">async </span><span class="enlighter-k1">function</span><span class="enlighter-text"> </span><span class="enlighter-m0">fileReq</span><span class="enlighter-g1">(</span><span class="enlighter-text">event</span><span class="enlighter-g1">){</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> const cache = caches.</span><span class="enlighter-m3">default</span><span class="enlighter-text">;</span><span class="enlighter-c0"> // Cloudflare edge caching</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> const url = </span><span class="enlighter-k1">new</span><span class="enlighter-text"> </span><span class="enlighter-m0">URL</span><span class="enlighter-g1">(</span><span class="enlighter-text">event.</span><span class="enlighter-m3">request</span><span class="enlighter-text">.</span><span class="enlighter-m3">url</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-k1">if</span><span class="enlighter-g1">(</span><span class="enlighter-text">url.</span><span class="enlighter-m3">host</span><span class="enlighter-text"> === b2Domain </span><span class="enlighter-g0">&amp;&amp;</span><span class="enlighter-text"> !url.</span><span class="enlighter-m3">pathname</span><span class="enlighter-text">.</span><span class="enlighter-m3">startsWith</span><span class="enlighter-g1">(</span><span class="enlighter-text">b2UrlPath</span><span class="enlighter-g1">)){</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> url.</span><span class="enlighter-m3">pathname</span><span class="enlighter-text"> = b2UrlPath + url.</span><span class="enlighter-m3">pathname</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> let response = await cache.</span><span class="enlighter-m3">match</span><span class="enlighter-g1">(</span><span class="enlighter-text">url</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span><span class="enlighter-c0"> // try to find match for this request in the edge cache</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-k1">if</span><span class="enlighter-g1">(</span><span class="enlighter-text">response</span><span class="enlighter-g1">){</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-c0"> // use cache found on Cloudflare edge. Set X-Worker-Cache header for helpful debug</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> let newHdrs = </span><span class="enlighter-m0">fixHeaders</span><span class="enlighter-g1">(</span><span class="enlighter-text">url, response.</span><span class="enlighter-m3">status</span><span class="enlighter-text">, response.</span><span class="enlighter-m3">headers</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> newHdrs.</span><span class="enlighter-m3">set</span><span class="enlighter-g1">(</span><span class="enlighter-s0">'X-Worker-Cache'</span><span class="enlighter-text">, </span><span class="enlighter-s0">"true"</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-k1">return</span><span class="enlighter-text"> </span><span class="enlighter-k1">new</span><span class="enlighter-text"> </span><span class="enlighter-m0">Response</span><span class="enlighter-g1">(</span><span class="enlighter-text">response.</span><span class="enlighter-m3">body</span><span class="enlighter-text">, </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> status: response.</span><span class="enlighter-m3">status</span><span class="enlighter-text">,</span></div></div><div class=""><div><span class="enlighter-text"> statusText: response.</span><span class="enlighter-m3">statusText</span><span class="enlighter-text">,</span></div></div><div class=""><div><span class="enlighter-text"> headers: newHdrs</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-g1">})</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-c0"> // no cache, fetch image, apply Cloudflare lossless compression</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> response = await </span><span class="enlighter-m0">fetch</span><span class="enlighter-g1">(</span><span class="enlighter-text">url, </span><span class="enlighter-g1">{</span><span class="enlighter-text">cf: </span><span class="enlighter-g1">{</span><span class="enlighter-text">polish: </span><span class="enlighter-s0">"lossless"</span><span class="enlighter-g1">}})</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> let newHdrs = </span><span class="enlighter-m0">fixHeaders</span><span class="enlighter-g1">(</span><span class="enlighter-text">url, response.</span><span class="enlighter-m3">status</span><span class="enlighter-text">, response.</span><span class="enlighter-m3">headers</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-k1">if</span><span class="enlighter-g1">(</span><span class="enlighter-text">response.</span><span class="enlighter-m3">status</span><span class="enlighter-text"> === </span><span class="enlighter-n1">200</span><span class="enlighter-g1">){</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> response = </span><span class="enlighter-k1">new</span><span class="enlighter-text"> </span><span class="enlighter-m0">Response</span><span class="enlighter-g1">(</span><span class="enlighter-text">response.</span><span class="enlighter-m3">body</span><span class="enlighter-text">, </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> status: response.</span><span class="enlighter-m3">status</span><span class="enlighter-text">,</span></div></div><div class=""><div><span class="enlighter-text"> statusText: response.</span><span class="enlighter-m3">statusText</span><span class="enlighter-text">,</span></div></div><div class=""><div><span class="enlighter-text"> headers: newHdrs</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-g1">})</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-g1">}</span><span class="enlighter-k1">else</span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> response = </span><span class="enlighter-k1">new</span><span class="enlighter-text"> </span><span class="enlighter-m0">Response</span><span class="enlighter-g1">(</span><span class="enlighter-s0">'File not found!'</span><span class="enlighter-text">, </span><span class="enlighter-g1">{</span><span class="enlighter-text"> status: </span><span class="enlighter-n1">404</span><span class="enlighter-text"> </span><span class="enlighter-g1">})</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"> event.</span><span class="enlighter-m3">waitUntil</span><span class="enlighter-g1">(</span><span class="enlighter-text">cache.</span><span class="enlighter-m3">put</span><span class="enlighter-g1">(</span><span class="enlighter-text">url, response.</span><span class="enlighter-m3">clone</span><span class="enlighter-g1">()))</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"> </span><span class="enlighter-k1">return</span><span class="enlighter-text"> response;</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-g1">}</span></div></div></div></div>6.workers里添加路由,使访问你的域名时,先走workers<figure class="wp-block-image size-large"><img src="https://dlcu.cf/GnuGH0pVbn.png" data-src="https://dlcu.cf/GnuGH0pVbn.png" alt="" class=" lazyloaded" /></figure>访问一下你的图片文件比如说一开始是https://f000.backblazeb2.com/file/backblaze1489498/wallhaven-md2x8m.jpg现在用https://dlcu.cf/wallhaven-md2x8m.jpg就可以访问了<p>7.配置ShareX.</p><p>这个感觉没啥好说的,主页面–目标–上传目标设置–backblaze b2,填上就行了</p><figure class="wp-block-image size-large"><img src="https://dlcu.cf/O6FVrPQlmZ.png" data-src="https://dlcu.cf/O6FVrPQlmZ.png" alt="" class=" lazyloaded" /></figure><h1 class="wp-block-zibllblock-biaoti title-theme" id="wznav_2">结束</h1>这个的好处就是方便了上传,自己在电脑前,截一下图直接上传,或者复制一下直接上传还有就是可以用自己的域名,再说的话就是数据自己也能找回.]]></content>
    
    
    <summary type="html">&lt;h1 class=&quot;wp-block-zibllblock-biaoti title-theme&quot; id=&quot;wznav_0&quot;&gt;准备&lt;/h1&gt;
1.一个cloudflare账号 https://dash.cloudflare.com/
2.一个B2账号 https://www.backblaze.com/b2/cloud-storage.html
3.windows软件ShareX</summary>
    
    
    
    
    <category term="cloudflare" scheme="http://example.com/tags/cloudflare/"/>
    
  </entry>
  
  <entry>
    <title>在多台服务器上部署哪吒探针 vps监控</title>
    <link href="http://example.com/2021/01/08/nezha/"/>
    <id>http://example.com/2021/01/08/nezha/</id>
    <published>2021-01-08T14:03:05.000Z</published>
    <updated>2021-11-20T11:23:25.372Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://inkup.cn/usr/uploads/2021/10/38754080.png"></p><span id="more"></span>开源地址：[https://github.com/naiba/nezha](https://github.com/naiba/nezha)  预览地址：[https://server.inkup.cn](https://server.inkup.cn)<p><strong>功能特性</strong></p><ul><li>  计划任务：备份脚本、服务重启，等定期运维任务。</li><li>  报警通知：CPU、内存、硬盘、带宽、流量实时监控。</li><li>  服务监控：HTTP、SSL证书、ping、TCP 端口等。</li><li>  自定义代码：改LOGO、改色调、加统计代码等。</li></ul><p><a href="https://github.com/naiba/nezha">详情见文档</a></p><p>部署教程<br><strong>一· 设置域名解析</strong><br>可以直接用 ip+端口 方式访问，为了安全及后期维护迁移方便，强烈建议设置用域名访问。准备两个域名，用本站域名举例：</p><ul><li>  域名1： a.moththe.com 作为面板访问域名，套 CDN（保护源站IP不泄露）。</li><li>域名2： b.moththe.com 不套CDN，指向面板服务器 IP，作为客户端与面板连接使用。<br>  两个域名都解析到部署面板服务器的IP。</li></ul><p><strong>二. 创建 GitHub OAuth Apps</strong><br>需要有Github账号，没有的话先注册一个。这一步让Github账号用作面板后台登录验证。</p><ol><li>创建 OAuth Apps<br> 打开 <a href="https://github.com/settings/developers">Github Developer settings</a> ，点击 New OAuth App 按钮</li></ol><p><img src="https://inkup.cn/usr/uploads/2021/10/4211366071.png" alt="请输入图片描述" title="请输入图片描述"></p><ol><li><p>填写站点名称和 URL 信息<br> 请参考图片填写，把 a.moththe.com 更换成自己面板域名，填写好以后点击 Register application 。</p><p> https://套CDN的域名<br> https://套CDN的域名/oauth2/callback</p></li></ol><p><img src="https://inkup.cn/usr/uploads/2021/10/4233705968.png" alt="请输入图片描述" title="请输入图片描述"></p><ol><li>获取 <em>OAuth Apps</em> 的 <em>Client ID</em> 和 <em>Client secret</em><br> 参照下图创建 client id 和 clients secret 并记下来。</li></ol><p><img src="https://inkup.cn/usr/uploads/2021/10/3344270305.png" alt="请输入图片描述" title="请输入图片描述"><br><strong>三. 部署哪吒探针面板端</strong></p><ol><li><p>放行对应端口<br> 放行8008、5555两个端口，这是默认的，如果你安装中改为其他端口，防火墙放行相应的端口。</p></li><li><p>一键安装脚本<br> 键入后按提示安装面板端，依次输入上面步骤获取的 Client ID ， Client secret 等相关信息。</p><p> curl -L <a href="https://raw.githubusercontent.com/naiba/nezha/master/script/install.sh">https://raw.githubusercontent.com/naiba/nezha/master/script/install.sh</a>  -o nezha.sh &amp;&amp; chmod +x nezha.sh<br> sudo ./nezha.sh</p></li></ol><p><img src="https://inkup.cn/usr/uploads/2021/10/279377451.png" alt="请输入图片描述" title="请输入图片描述"><br><strong>四. 设置域名访问</strong></p><ol><li>设置反向代理<br> 在宝塔面板中新建站点，我这里是套CDN的域名，然后设置反代。</li></ol><p><img src="https://inkup.cn/usr/uploads/2021/10/243714898.png" alt="请输入图片描述" title="请输入图片描述"><br>反代配置文件</p><pre><code>location /&#123;    proxy_pass http://127.0.0.1:8008;    proxy_set_header Host $host;&#125;location /ws&#123;    proxy_pass http://127.0.0.1:8008;    proxy_http_version 1.1;    proxy_set_header Upgrade $http_upgrade;    proxy_set_header Connection &quot;Upgrade&quot;;    proxy_set_header Host $host;&#125;</code></pre><ol><li>配置 SSL 证书<br> 直接在宝塔面板中一键获取 Let’s Encrypt 免费证书。如果域名托管在 Cloudflare，也可以使用CF生成的免费长期证书，填在面板中使用。然后开启强制 HTTPS 即可。</li></ol><p>现在就可以直接通过域名访问哪吒探针了，现在我们来配置被监控的服务器。</p><p><strong>五. 部署哪吒探针客户端（被监控）</strong></p><ol><li>在哪吒面板中生成客户端连接密钥<br> 打开哪吒面板，点击登录后台，通过GitHub账号验证后进入管理后台，添加服务器，创建好以后记下生成的密钥</li></ol><p><img src="https://inkup.cn/usr/uploads/2021/10/1695118959.png" alt="请输入图片描述" title="请输入图片描述"></p><ol><li><p>一键安装客户端<br> 键入后按提示 安装监控Agent ，依次输入 域名2(我这里是不套CDN的域名），上一步骤中生成的连接密钥等相关信息。</p><p> curl -L <a href="https://raw.githubusercontent.com/naiba/nezha/master/script/install.sh">https://raw.githubusercontent.com/naiba/nezha/master/script/install.sh</a>  -o nezha.sh &amp;&amp; chmod +x nezha.sh<br> sudo ./nezha.sh</p></li></ol><p><img src="https://inkup.cn/usr/uploads/2021/10/2649339818.png" alt="请输入图片描述" title="请输入图片描述"><br>有多台被监控机器时，按照此步骤在控制面板添加服务器。其他功能可自行在哪吒面板后台摸索。</p><p><strong><em>常见问题</em></strong><br>1· 打开显示断开实时链接<br>可以关闭CDN再试试。</p><p>2· Centos8 中部署客户端或者面板端，一直显示离线<br>请关闭SElinux，打开配置文件 vi /etc/selinux/config ，将 SELINUX=enforcing 改为 SELINUX=disabled ，重启机器 reboot ，然后键入安装脚本选择 重启Agent 。</p><p>3· 修改服务器信息后变成离线<br>在安装客户端(被监控)的服务器上执行 systemctl restart nezha-agent 重启程序。</p><p>4· 启动nezha-agent还是一直显示离线<br>检查配置有没有写对 cat /etc/systemd/system/nezha-agent.service | grep ExecStart 。</p><p>5· 如何进行数据迁移、备份恢复？<br>数据储存在 /opt/nezha 文件夹中，迁移数据时打包这个文件夹，到新环境解压。然后执行一键脚本安装即可。</p><p>6· 首页服务器随机闪烁掉线？<br>执行 ntpdate 0.pool.ntp.org 同步一下面板部署所在的服务器的时间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://inkup.cn/usr/uploads/2021/10/38754080.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器使用 Rclone 挂载 OneDrive</title>
    <link href="http://example.com/2021/01/01/onedrive/"/>
    <id>http://example.com/2021/01/01/onedrive/</id>
    <published>2021-01-01T14:06:50.000Z</published>
    <updated>2021-11-20T11:23:05.140Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过挂载 Google Drive 的过程，因为我的 Google Drive 空间不大，而 OneDrive 有 5T 的空间，所以准备把 OneDrive 挂载上去使用。OneDrive 的挂载方法和 Google Drive 大部分是差不多的，但 OneDrive 的授权要麻烦一些。</p><p>这里简单记录一下我配置的过程。<span id="more"></span>**下载安装**  使用脚本下载安装 Rclone：<pre><code>curl https://rclone.org/install.sh | sudo bash</code></pre><p>初始化配置<br>安装完成后输入：</p><pre><code>rclone config</code></pre><p>可以看到：</p><pre><code>2021/04/14 07:14:46 NOTICE: Config file &quot;/root/.config/rclone/rclone.conf&quot; not found - using defaults</code></pre><p>No remotes found - make a new one<br>n) New remote<br>s) Set configuration password<br>q) Quit config</p><p>输入 n 新建配置。</p><p>name 可以随便输入，</p><p>然后会出现挂载的服务类型，如下：</p><pre><code>Type of storage to configure.</code></pre><p>Enter a string value. Press Enter for the default (“”).<br>Choose a number from below, or type in your own value<br>1 / 1Fichier<br>“fichier”<br>2 / Alias for an existing remote<br>“alias”<br>3 / Amazon Drive<br>“amazon cloud drive”<br>4 / Amazon S3 Compliant Storage Providers including AWS, Alibaba, Ceph, Digital Ocean, Dreamhost, IBM COS, Minio, and Tencent COS<br>“s3”<br>5 / Backblaze B2<br>“b2”<br>6 / Box<br>“box”<br>7 / Cache a remote<br>“cache”<br>8 / Citrix Sharefile<br>“sharefile”<br>9 / Compress a remote<br>“compress”<br>10 / Dropbox<br>“dropbox”<br>11 / Encrypt/Decrypt a remote<br>“crypt”<br>12 / Enterprise File Fabric<br>“filefabric”<br>13 / FTP Connection<br>“ftp”<br>14 / Google Cloud Storage (this is not Google Drive)<br>“google cloud storage”<br>15 / Google Drive<br>“drive”<br>16 / Google Photos<br>“google photos”<br>17 / Hadoop distributed file system<br>“hdfs”<br>18 / Hubic<br>“hubic”<br>19 / In memory object storage system.<br>“memory”<br>20 / Jottacloud<br>“jottacloud”<br>21 / Koofr<br>“koofr”<br>22 / Local Disk<br>“local”<br>23 / Mail.ru Cloud<br>“mailru”<br>24 / Mega<br>“mega”<br>25 / Microsoft Azure Blob Storage<br>“azureblob”<br>26 / Microsoft OneDrive<br>“onedrive”<br>27 / OpenDrive<br>“opendrive”<br>28 / OpenStack Swift (Rackspace Cloud Files, Memset Memstore, OVH)<br>“swift”<br>29 / Pcloud<br>“pcloud”<br>30 / Put.io<br>“putio”<br>31 / QingCloud Object Storage<br>“qingstor”<br>32 / SSH/SFTP Connection<br>“sftp”<br>33 / Sugarsync<br>“sugarsync”<br>34 / Tardigrade Decentralized Cloud Storage<br>“tardigrade”<br>35 / Transparently chunk/split large files<br>“chunker”<br>36 / Union merges the contents of several upstream fs<br>“union”<br>37 / Webdav<br>“webdav”<br>38 / Yandex Disk<br>“yandex”<br>39 / Zoho<br>“zoho”<br>40 / http Connection<br>“http”<br>41 / premiumize.me<br>“premiumizeme”<br>42 / seafile<br>“seafile”</p><p>直接输入序号，比如我挂载的是 OneDrive 就可以输入 26 ，</p><p>client_id 可以直接回车默认，</p><p>client_secret 也可以直接回车默认，</p><p>然后会出现 OneDrive 区域选择，如下：</p><pre><code>Choose national cloud region for OneDrive.</code></pre><p>Enter a string value. Press Enter for the default (“global”).<br>Choose a number from below, or type in your own value<br>1 / Microsoft Cloud Global<br>“global”<br>2 / Microsoft Cloud for US Government<br>“us”<br>3 / Microsoft Cloud Germany<br>“de”<br>4 / Azure and Office 365 operated by 21Vianet in China<br>“cn”</p><p>可以直接输入 1 选择全球，</p><p>然后是选择是否进行高级配置，如下：</p><pre><code>dit advanced config? (y/n)</code></pre><p>y) Yes<br>n) No (default)</p><p>可以输入 n ，</p><p>接着是自动配置选择，如下：</p><pre><code>Remote config</code></pre><p>Use auto config?</p><ul><li>  Say Y if not sure</li><li>Say N if you are working on a remote or headless machine<br>  y) Yes (default)</li></ul><p>n) No</p><p>可以输入 n ，</p><p>这里需要获取授权码：</p><pre><code>For this to work, you will need rclone available on a machine that has</code></pre><p>a web browser available.</p><p>For more help and alternate methods see: <a href="https://rclone.org/remote_setup/">https://rclone.org/remote_setup/</a></p><p>Execute the following on the machine with the web browser (same rclone<br>version recommended):</p><pre><code>rclone authorize &quot;onedrive&quot;</code></pre><p>Then paste the result below:</p><p>授权码需要在本地电脑上获取，访问 <a href="https://rclone.org/downloads/">https://rclone.org/downloads/</a> 根据你的电脑系统版本下载对应的 Rclone。</p><p>下载完成后解压，进入存放 Rclone 的目录，以 Win10 为例，打开 Powershell ，我的 Rclone 放在 E:下载rclone-v1.55.0-windows-amd64 ，我可以输入：</p><pre><code>cd E:\下载\rclone-v1.55.0-windows-amd64</code></pre><p>在存放 Rclone 的目录可以看到 rclone.exe 的可执行程序，输入：</p><pre><code>./rclone authorize &quot;onedrive&quot;</code></pre><p>浏览器应该会自动打开，如果浏览器没有打开可以根据提示复制地址访问。如果浏览器登录了 OneDrive 的话会直接显示授权确认信息，如果没有登录的话会弹出登录页面，登录 OneDrive 后也会显示授权确认信息，如下：<br><img src="https://www.misterma.com/img-admin/uploads/16184932694425.jpeg" alt="请输入图片描述" title="请输入图片描述"></p><p>选择 接受 后在本地命令行会显示一串 JSON 格式的授权信息，复制授权信息包括首尾的 {} ，到 Linux 终端粘贴。</p><p>然后是选择 OneDrive 的类型，如下：</p><pre><code>Choose a number from below, or type in an existing value</code></pre><p>1 / OneDrive Personal or Business<br>“onedrive”<br>2 / Root Sharepoint site<br>“sharepoint”<br>3 / Sharepoint site name or URL (e.g. mysite or <a href="https://contoso.sharepoint.com/sites/mysite">https://contoso.sharepoint.com/sites/mysite)</a>)<br>“url”<br>4 / Search for a Sharepoint site<br>“search”<br>5 / Type in driveID (advanced)<br>“driveid”<br>6 / Type in SiteID (advanced)<br>“siteid”<br>7 / Sharepoint server-relative path (advanced, e.g. /teams/hr)<br>“path”</p><p>可以输入 1 ，</p><p>然后会显示找到的 OneDrive 账户，如下：</p><p>Found 1 drives, please select the one you want to use:<br>0: OneDrive (business) id=b!b_xnJJqyBMSVPjgvhvbP8XmJ_M_dMjhzrbhnaWknnbKqNBm8MTqM3kvEtW67P</p><pre><code>Found drive &#39;root&#39; of type &#39;business&#39;, URL: https://xxx-my.sharepoint.com/personal/changbin_xxx_onmicrosoft_com/Documents</code></pre><p>Is that okay?<br>y) Yes (default)<br>n) No</p><p>确认无误后输入 y ，</p><p>接着会显示你选择的配置信息，确认无误后输入 y 保存配置。</p><p>挂载<br>输入：</p><pre><code>rclone mount configName:OneDriveLocation dir --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000</code></pre><p>其中的 configName 就是配置名称，OneDriveLocation 就是要挂载的 OneDrive 目录，dir 就是要挂载到的本地目录。</p><p>例如我要把一个名为 OneDrive 的配置挂载到本地的 /OneDrive 目录，我可以这样写：</p><pre><code>rclone mount OneDrive:/ /OneDrive --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000</code></pre><p>我这里挂载的是整个 OneDrive 网盘，所以我写的是 OneDrive 的根目录 / 。</p><p>挂载完成后不会显示任何内容，可以再开一个终端，输入 df -h 查看磁盘空间，如下：</p><pre><code>Filesystem         Size  Used Avail Use% Mounted on</code></pre><p>devtmpfs 1.5G 0 1.5G 0% /dev<br>tmpfs 1.5G 0 1.5G 0% /dev/shm<br>tmpfs 1.5G 153M 1.4G 11% /run<br>tmpfs 1.5G 0 1.5G 0% /sys/fs/cgroup<br>/dev/vda1 57G 26G 29G 48% /<br>tmpfs 301M 0 301M 0% /run/user/0<br>OneDrive 5.0T 1.1T 4.0T 21% /OneDrive</p><p>挂载完成后进入挂载的目录就可以看到 OneDrive 的文件了，上传文件可以直接拷贝到挂载目录，下载也是直接拷贝到本地目录。</p><p>挂载出错<br>如果在挂载的时候出现了类似下面的提示：</p><pre><code>2021/03/04 18:58:16 Fatal error: failed to mount FUSE fs: fusermount: exec: &quot;fusermount&quot;: executable file not found in $PATH</code></pre><p>需要安装 fuse。</p><p>CentOS/Fedora 安装 fuse：</p><p>yum install -y fuse<br>Ubuntu/Debian 安装 fuse：</p><p>apt install -y fuse</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前写过挂载 Google Drive 的过程，因为我的 Google Drive 空间不大，而 OneDrive 有 5T 的空间，所以准备把 OneDrive 挂载上去使用。OneDrive 的挂载方法和 Google Drive 大部分是差不多的，但 OneDrive 的授权要麻烦一些。&lt;/p&gt;&lt;p&gt;这里简单记录一下我配置的过程。</summary>
    
    
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 中嵌入HTML实现其他功能</title>
    <link href="http://example.com/2020/11/20/Markdown-3/"/>
    <id>http://example.com/2020/11/20/Markdown-3/</id>
    <published>2020-11-20T07:12:51.000Z</published>
    <updated>2021-11-20T07:14:57.846Z</updated>
    
    <content type="html"><![CDATA[<p>自从几年前开始在 GitHub 玩耍，接触到 Markdown 之后，就一发不可收拾，在各种文档编辑上，有条件用 Markdown 的尽量用，不能用的创造条件也要用——README、博客、公众号、接口文档等等全都是，比如当前这篇文章就是用 Markdown 编辑而成。</p><span id="more"></span><p>这几年也发现越来越多的网站和程序提供了对 Markdown 的支持，从最初接触的 GitHub、Jekyll，到简书、掘金、CSDN 等等，由此也从别人做得好的文档中，学到了一些『奇技淫巧』，所以本文不是对 Markdown 基础语法的介绍，而是一些相对高级、能将 Markdown 玩出更多花样的小技巧。</p><p><em>注：如下技巧大多是利用 Markdown 兼容部分 HTML 标签的特性来完成，不一定在所有网站和软件里都完全支持，主要以 GitHub 支持为准。</em></p><h2 id="在表格单元格里换行"><a href="#在表格单元格里换行" class="headerlink" title="在表格单元格里换行"></a>在表格单元格里换行</h2><p>借助于 HTML 里的 <code>&lt;br /&gt;</code> 实现。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| Header1 | Header2                          |</span><br><span class="line">|---------|----------------------------------|</span><br><span class="line">| item 1  | 1. one&lt;br /&gt;2. two&lt;br /&gt;3. three | </span><br></pre></td></tr></table></figure><p>示例效果：</p><table><thead><tr><th>Header1</th><th>Header2</th></tr></thead><tbody><tr><td>item 1</td><td>1. one</td></tr><tr><td>2. two</td><td></td></tr><tr><td>3. three</td><td></td></tr></tbody></table><h2 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h2><p>使用 <code>&lt;img&gt;</code> 标签来贴图，然后指定 <code>align</code> 属性。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;img align=&quot;right&quot; src=&quot;https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/markdown/demo.png&quot;/&gt;</span><br><span class="line"></span><br><span class="line">这是一个示例图片。</span><br><span class="line"></span><br><span class="line">图片显示在 N 段文字的右边。</span><br><span class="line"></span><br><span class="line">N 与图片高度有关。</span><br><span class="line"></span><br><span class="line">刷屏行。</span><br><span class="line"></span><br><span class="line">刷屏行。</span><br><span class="line"></span><br><span class="line">到这里应该不会受影响了，本行应该延伸到了图片的正下方，所以我要足够长才能确保不同的屏幕下都看到效果。 </span><br></pre></td></tr></table></figure><p>示例效果：</p><p><img src="https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/markdown/demo.png"></p><p>这是一个示例图片。</p><p>图片显示在 N 段文字的右边。</p><p>N 与图片高度有关。</p><p>刷屏行。</p><p>刷屏行。</p><p>到这里应该不会受影响了，本行应该延伸到了图片的正下方，所以我要足够长才能确保不同的屏幕下都看到效果。</p><h2 id="控制图片大小和位置"><a href="#控制图片大小和位置" class="headerlink" title="控制图片大小和位置"></a>控制图片大小和位置</h2><p>标准的 Markdown 图片标记 <code>![]()</code> 无法指定图片的大小和位置，只能依赖默认的图片大小，默认居左。</p><p>而有时候源图太大想要缩小一点，或者想将图片居中，就仍需要借助 HTML 的标签来实现了。图片居中可以使用 <code>&lt;div&gt;</code> 标签加 <code>align</code> 属性来控制，图片宽高则用 <code>width</code> 和 <code>height</code> 来控制。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**图片默认显示效果：**</span><br><span class="line"></span><br><span class="line">![](/images/posts/markdown/demo.png)</span><br><span class="line"></span><br><span class="line">**加以控制后的效果：**</span><br><span class="line"></span><br><span class="line">&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;65&quot; height=&quot;75&quot; src=&quot;https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/markdown/demo.png&quot;/&gt;&lt;/div&gt; </span><br></pre></td></tr></table></figure><p>示例效果：</p><p><strong>图片默认显示效果：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images/posts/markdown/demo.png"></p><p><strong>加以控制后的效果：</strong></p><p><img src="https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/markdown/demo.png"></p><h2 id="格式化表格"><a href="#格式化表格" class="headerlink" title="格式化表格"></a>格式化表格</h2><p>表格在渲染之后很整洁好看，但是在文件源码里却可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|Header1|Header2|</span><br><span class="line">|---|---|</span><br><span class="line">|a|a|</span><br><span class="line">|ab|ab|</span><br><span class="line">|abc|abc| </span><br></pre></td></tr></table></figure><p>不知道你能不能忍，反正我是不能忍。</p><p>好在广大网友们的智慧是无穷的，在各种编辑器里为 Markdown 提供了表格格式化功能，比如我使用 Vim 编辑器，就有 <a href="https://github.com/dhruvasagar/vim-table-mode">vim-table-mode</a> 插件，它能帮我自动将表格格式化成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Header1 | Header2 |</span><br><span class="line">|---------|---------|</span><br><span class="line">| a       | a       |</span><br><span class="line">| ab      | ab      |</span><br><span class="line">| abc     | abc     | </span><br></pre></td></tr></table></figure><p>是不是看着舒服多了？</p><p>如果你不使用 Vim，也没有关系，比如 Atom 编辑器的 <a href="https://atom.io/packages/markdown-table-formatter">markdown-table-formatter</a> 插件，Sublime Text 3 的 <a href="https://github.com/bitwiser73/MarkdownTableFormatter">MarkdownTableFormatter</a> 等等，都提供了类似的解决方案。</p><h2 id="使用-Emoji"><a href="#使用-Emoji" class="headerlink" title="使用 Emoji"></a>使用 Emoji</h2><p>这个是 GitHub 对标准 Markdown 标记之外的扩展了，用得好能让文字生动一些。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我和我的小伙伴们都笑了。:smile: </span><br></pre></td></tr></table></figure><p>示例效果：</p><p>我和我的小伙伴们都笑了。<img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" alt=":smile:" title=":smile:"></p><p>更多可用 Emoji 代码参见 <a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/">https://www.webpagefx.com/tools/emoji-cheat-sheet/</a>。</p><h2 id="行首缩进"><a href="#行首缩进" class="headerlink" title="行首缩进"></a>行首缩进</h2><p>直接在 Markdown 里用空格和 Tab 键缩进在渲染后会被忽略掉，需要借助 HTML 转义字符在行首添加空格来实现，<code>&amp;ensp;</code> 代表半角空格，<code>&amp;emsp;</code> 代表全角空格。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;春天来了，又到了万物复苏的季节。 </span><br></pre></td></tr></table></figure><p>示例效果：</p><p>  春天来了，又到了万物复苏的季节。</p><h2 id="展示数学公式"><a href="#展示数学公式" class="headerlink" title="展示数学公式"></a>展示数学公式</h2><p>如果是在 GitHub Pages，可以参考 <a href="http://wanguolin.github.io/mathmatics_rending/">http://wanguolin.github.io/mathmatics_rending/</a> 使用 MathJax 来优雅地展示数学公式（非图片）。</p><p>如果是在 GitHub 项目的 README 等地方，目前我能找到的方案只能是贴图了，以下是一种比较方便的贴图方案：</p><ol><li>在 <a href="https://www.codecogs.com/latex/eqneditor.php">https://www.codecogs.com/latex/eqneditor.php</a> 网页上部的输入框里输入 LaTeX 公式，比如 <code>$$x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;$$</code>；</li><li>在网页下部拷贝 URL Encoded 的内容，比如以上公式生成的是 <code>https://latex.codecogs.com/png.latex?%24%24x%3D%5Cfrac%7B-b%5Cpm%5Csqrt%7Bb%5E2-4ac%7D%7D%7B2a%7D%24%24</code>； <img src="https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images/posts/markdown/latex-img.png"></li><li>在文档需要的地方使用以上 URL 贴图，比如 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://latex.codecogs.com/png.latex?%24%24x%3D%5Cfrac%7B-b%5Cpm%5Csqrt%7Bb%5E2-4ac%7D%7D%7B2a%7D%24%24) </span><br></pre></td></tr></table></figure> 示例效果： <img src="https://latex.codecogs.com/png.latex?$$x=%5Cfrac%7B-b%5Cpm%5Csqrt%7Bb%5E2-4ac%7D%7D%7B2a%7D$$"></li></ol><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>在 GitHub 和 GitLab 等网站，除了可以使用有序列表和无序列表外，还可以使用任务列表，很适合要列出一些清单的场景。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**购物清单**</span><br><span class="line"></span><br><span class="line">- [ ] 一次性水杯</span><br><span class="line">- [x] 西瓜</span><br><span class="line">- [ ] 豆浆</span><br><span class="line">- [x] 可口可乐</span><br><span class="line">- [ ] 小茗同学 </span><br></pre></td></tr></table></figure><p>示例效果：</p><p><strong>购物清单</strong></p><ul><li>  [ ] 一次性水杯</li><li>  [x] 西瓜</li><li>  [ ] 豆浆</li><li>  [x] 可口可乐</li><li>  [ ] 小茗同学</li></ul><h2 id="自动维护目录"><a href="#自动维护目录" class="headerlink" title="自动维护目录"></a>自动维护目录</h2><p>有时候维护一份比较长的文档，希望能够自动根据文档中的标题生成目录（Table of Contents），并且当标题有变化时自动更新目录，能减轻工作量，也不易出错。</p><p>如果你使用 Vim 编辑器，那可以使用我维护的插件 <a href="https://github.com/mzlogin/vim-markdown-toc">vim-markdown-toc</a> 来帮你完美地解决此事：</p><p><img src="https://raw.githubusercontent.com/mzlogin/vim-markdown-toc/master/screenshots/english.gif"></p><p>插件地址：<a href="https://github.com/mzlogin/vim-markdown-toc">https://github.com/mzlogin/vim-markdown-toc</a></p><p>如果你使用其它编辑器，一般也能找到对应的解决方案，比如 Atom 编辑器的 <a href="https://atom.io/packages/markdown-toc">markdown-toc</a> 插件，Sublime Text 的 <a href="https://packagecontrol.io/packages/MarkdownTOC">MarkdownTOC</a> 插件等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自从几年前开始在 GitHub 玩耍，接触到 Markdown 之后，就一发不可收拾，在各种文档编辑上，有条件用 Markdown 的尽量用，不能用的创造条件也要用——README、博客、公众号、接口文档等等全都是，比如当前这篇文章就是用 Markdown 编辑而成。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MarkDown" scheme="http://example.com/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>Docker超详细基础教程</title>
    <link href="http://example.com/2020/11/17/docker/"/>
    <id>http://example.com/2020/11/17/docker/</id>
    <published>2020-11-17T10:48:27.000Z</published>
    <updated>2021-11-17T11:08:04.946Z</updated>
    
    <content type="html"><![CDATA[<img src="https://img-blog.csdnimg.cn/img_convert/93b3e0fd73f78f9cdc0fda5b5a5ce62f.png"/><h1 id="一-Docker介绍"><a href="#一-Docker介绍" class="headerlink" title="一.Docker介绍"></a><strong>一.Docker介绍</strong></h1><p> Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。<br> Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br> 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。<br> Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）。</p><span id="more"></span><h1 id="二-Docker的基本操作"><a href="#二-Docker的基本操作" class="headerlink" title="二.Docker的基本操作"></a><strong>二.Docker的基本操作</strong></h1><h2 id="2-1基本准备"><a href="#2-1基本准备" class="headerlink" title="2.1基本准备"></a><strong>2.1基本准备</strong></h2><p>这篇文章中我的运行环境都是在CentOS7中运行。</p><h2 id="2-2安装Docker"><a href="#2-2安装Docker" class="headerlink" title="2.2安装Docker"></a><strong>2.2安装Docker</strong></h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.下载关于Docker的依赖环境</span><br><span class="line">yum -y install yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.设置下载Docker的镜像源</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4.启动Docker，并设置为开机自动启动，测试</span><br><span class="line"># 启动Docker服务</span><br><span class="line">systemctl start docker</span><br><span class="line"># 设置开机自动启动</span><br><span class="line">systemctl enable docker</span><br><span class="line"># 测试</span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="2-3-Docker的中央仓库"><a href="#2-3-Docker的中央仓库" class="headerlink" title="2.3 Docker的中央仓库"></a><strong>2.3 Docker的中央仓库</strong></h2><ol><li>Docker官方的中央仓库: 这个仓库是镜像最全的，但是下载速度较慢。<br><a href="https://hub.docker.com/">https://hub.docker.com/</a></li><li>国内的镜像网站：网易蜂巢、daoCloud。。。<br><a href="https://c.163yun.com/hub#/home">https://c.163yun.com/hub#/home</a><br><a href="https://hub.daocloud.io/">https://hub.daocloud.io/</a> (推荐使用)</li><li>在公司内部会采用私服的方式拉取镜像。(添加配置)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 需要在/etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;],</span><br><span class="line">&quot;insecure-registries&quot;: [&quot;ip:port]</span><br><span class="line">&#125;</span><br><span class="line"># ip:port</span><br><span class="line">公司私服的ip和port</span><br><span class="line"># 重启两个服务</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker                          </span><br></pre></td></tr></table></figure><h2 id="2-4-镜像的操作"><a href="#2-4-镜像的操作" class="headerlink" title="2.4 镜像的操作"></a><strong>2.4 镜像的操作</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 1. 拉取镜像到本地</span><br><span class="line">docker pull 镜像名称[:tag]</span><br><span class="line"># 举个例子 tomcat</span><br><span class="line">docker pull daocloud.io/library/tomcat:8.5.15-jre8</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 2. 查看全部本地的镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 3. 删除本地镜像</span><br><span class="line">docker rmi 镜像的标识</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 4. 镜像的导入导出(不规范)</span><br><span class="line"># 将本地的镜像导出</span><br><span class="line">docker save -o 导出的路径 镜像id</span><br><span class="line"># 加载本地的镜像文件</span><br><span class="line">docker load -i 镜像文件</span><br><span class="line"># 修改镜像名称</span><br><span class="line">docker tag 镜像id 新镜像名称:版本</span><br></pre></td></tr></table></figure><h2 id="2-5-容器的操作"><a href="#2-5-容器的操作" class="headerlink" title="2.5 容器的操作"></a><strong>2.5 容器的操作</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1. 运行容器</span><br><span class="line"># 简单操作</span><br><span class="line">docker run 镜像的标识|镜像名称[tag]</span><br><span class="line"># 常用的参数</span><br><span class="line">docker run -d -p  宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[tag]</span><br><span class="line"># -d: 代表后台运行容器</span><br><span class="line"># -p: 宿主机端口:容器端口: 为了映射当前Linux的端口和容器的端口</span><br><span class="line"># --name 容器名称: 指定容器的名称</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 2. 查看正在运行的容器</span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line"># OPTIONS说明:</span><br><span class="line"># -a: 代表查看全部的容器，包括没有运行</span><br><span class="line"># -q: 只查看容器的标识</span><br><span class="line"># -f: 根据条件过滤显示的内容</span><br><span class="line"># --format: 指定返回值的模板文件</span><br><span class="line"># -l: 显示最近创建的容器</span><br><span class="line"># -n: 列出最近创建的n个容器</span><br><span class="line"># --no-trunc: 不截断输出</span><br><span class="line"># -s: 显示总的文件大小</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 3. 查看容器的日志</span><br><span class="line">docker logs -f 容器id</span><br><span class="line"># -f: 可以滚动查看日志的最后几行</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 4. 进入到容器内部</span><br><span class="line">docker exec -it 容器id bash</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 5. 删除容器(删除容器前，需要先停止容器)</span><br><span class="line">docker stop 容器id</span><br><span class="line"># 停止指定的容器</span><br><span class="line">docker stop $(docker ps -qa)</span><br><span class="line"># 停止全部容器</span><br><span class="line">docker rm 镜像id</span><br><span class="line"># 删除指定容器</span><br><span class="line">docker rm $(docker ps -qa)</span><br><span class="line"># 删除全部容器</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#6. 启动容器</span><br><span class="line">docker start 容器id</span><br></pre></td></tr></table></figure><h1 id="三-Docker应用"><a href="#三-Docker应用" class="headerlink" title="三.Docker应用"></a><strong>三.Docker应用</strong></h1><h2 id="3-1-准备SSM工程"><a href="#3-1-准备SSM工程" class="headerlink" title="3.1 准备SSM工程"></a><strong>3.1 准备SSM工程</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># MySQL数据库的连接用户名和密码改变了，修改db.propreties</span><br><span class="line"># 项目重新打包</span><br><span class="line">mvn clean package -DskipTests</span><br><span class="line"># 项目地址</span><br><span class="line">链接: https://pan.baidu.com/s/1F4xTLoOFCMb7rl1VUrBASA  密码: bgjw</span><br></pre></td></tr></table></figure><h2 id="3-2-准备MySQL容器"><a href="#3-2-准备MySQL容器" class="headerlink" title="3.2 准备MySQL容器"></a><strong>3.2 准备MySQL容器</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 运行MySQL容器</span><br><span class="line">docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root  daocloud.io/library/mysql:5.7.4</span><br></pre></td></tr></table></figure><h2 id="3-3-准备Tomcat容器"><a href="#3-3-准备Tomcat容器" class="headerlink" title="3.3 准备Tomcat容器"></a><strong>3.3 准备Tomcat容器</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 运行Tomcat容器，在上面容器操作中已经搞定，只需要将SSM项目的war包部署到Tomcat容器内部</span><br><span class="line"># 可以通过命令将宿主机的内容复制到容器内部</span><br><span class="line">docker cp 文件名称 容器id:容器内部路径</span><br><span class="line"># 举个例子</span><br><span class="line">docker cp ssm.war fe:/usr/local/tomcat/webapps/</span><br></pre></td></tr></table></figure><h1 id="四-Docker自定义镜像"><a href="#四-Docker自定义镜像" class="headerlink" title="四.Docker自定义镜像"></a><strong>四.Docker自定义镜像</strong></h1>中央仓库上的镜像，也是Docker的用户自己上传过去的。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 1. 创建一个Dockerfile文件，并且指定自定义镜像信息。</span><br><span class="line"># Dockerfile文件中常用的内容</span><br><span class="line">from: 指定当前自定义镜像依赖的环境</span><br><span class="line">copy: 将相对路径下的内容复制到自定义镜像中</span><br><span class="line">workdir: 声明镜像的默认工作目录</span><br><span class="line">cmd: 需要执行的命令(在workdir下执行的，cmd可以写多个，只以最后一个为准)</span><br><span class="line"># 举个例子，自定义一个tomcat镜像，并且将ssm.war部署到tomcat中</span><br><span class="line">from daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">copy ssm.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 2. 将准备好的Dockerfile和相应的文件拖拽到Linux操作系统中，通过Docker的命令制作镜像</span><br><span class="line">docker build -t 镜像名称:[tag] .</span><br></pre></td></tr></table></figure><h1 id="五-Docker-Compose"><a href="#五-Docker-Compose" class="headerlink" title="五.Docker-Compose"></a><strong>五.Docker-Compose</strong></h1>之前运行一个镜像，需要添加大量的参数。<br>可以通过Docker-Compose编写这些参数。<br>Docker-Compose可以帮助我们批量的管理容器。<br>只需要通过一个docker-compose.yml文件去维护即可。<h2 id="5-1-下载Docker-Compose"><a href="#5-1-下载Docker-Compose" class="headerlink" title="5.1 下载Docker-Compose"></a><strong>5.1 下载Docker-Compose</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 1. 去Github官网搜索docker-compose，下载1.24.1版本的Docker-Compose</span><br><span class="line">https://github.com/docker/compose/releases/download/1.24.1/docker-compose-Linux-x86_64</span><br><span class="line"></span><br><span class="line"># 2. 将下载好的文件拖拽到Linux系统中</span><br><span class="line">将文件上传到你所使用的服务器或者虚拟机，然后将文件移动到/usr/local</span><br><span class="line"></span><br><span class="line"># 3. 需要将Docker-Compose文件的名称修改一下，基于Docker-Compose文件一个可执行的权限</span><br><span class="line">mv docker-compose-Linux-x86_64 docker-compose</span><br><span class="line">chmod 777 docker-compose</span><br><span class="line"></span><br><span class="line"># 4. 方便后期操作，配置一个环境变量</span><br><span class="line"># 将docker-compose文件移动到了/usr/local/bin，修改了/etc/profile文件，给/usr/local/bin配置到了PATH中</span><br><span class="line">mv docker-compose /usr/local/bin</span><br><span class="line">vi /etc/profile</span><br><span class="line">export PATH=/usr/local/bin:$PATH</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"># 5. 测试一下</span><br><span class="line"># 在任意目录下输入docker-compose</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/img_convert/b6e4b1a31be51f5269ddda3ac195dbe8.png"/></li></ol><h2 id="5-2-Docker-Compose管理MySQL和Tomcat容器"><a href="#5-2-Docker-Compose管理MySQL和Tomcat容器" class="headerlink" title="5.2 Docker-Compose管理MySQL和Tomcat容器"></a><strong>5.2 Docker-Compose管理MySQL和Tomcat容器</strong></h2><p> yml文件以key:value方式来指定配置信息<br> 多个配置信息以换行+缩进的方式来区分<br> 在docker-compose.yml文件中，不要使用制表符</p><p> version: ‘3.1’<br> services:<br>   mysql:                     # 服务的名称<br>     restart: always          # 代表只要Docker启动，那么这个容器就跟着一起启动<br>     image: daocloud.io/library/mysql:5.7.4     # 指定镜像路径<br>     container_name: mysql    # 指定容器名称<br>     ports:<br>       - 3306:3306        # 指定端口号的映射<br>     environment:<br>       MYSQL_ROOT_PASSWORD: root         # 指定MySQL的ROOT用户登录密码<br>       TZ: Asia/Shanghai                 # 指定时区<br>     volumes:<br>       - /opt/docker_mysql_tomcat/mysql_data:/var/lib/mysql        # 映射数据卷<br>   tomcat:<br>     restart: always          # 代表只要Docker启动，那么这个容器就跟着一起启动<br>     image: daocloud.io/library/tomcat:8.5.15-jre8     # 指定镜像路径<br>     container_name: tomcat    # 指定容器名称<br>     ports:<br>       - 8080:8080        # 指定端口号的映射<br>     environment:<br>       MYSQL_ROOT_PASSWORD: root         # 指定MySQL的ROOT用户登录密码<br>       TZ: Asia/Shanghai                 # 指定时区<br>     volumes:<br>       - /opt/docker_mysql_tomcat/tomcat_webapps:/usr/local/tomcat/webapps        # 映射数据卷<br>       - /opt/docker_mysql_tomcat/tomcat_logs:/usr/local/tomcat/ logs        # 映射数据卷</p><h2 id="5-3-使用docker-compose命令管理容器"><a href="#5-3-使用docker-compose命令管理容器" class="headerlink" title="5.3 使用docker-compose命令管理容器"></a><strong>5.3 使用docker-compose命令管理容器</strong></h2><p> 在使用docker-compose的命令时，默认会在当前目录下找docker-compose.yml<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 1. 基于docker-compose.yml启动管理的容器</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 2. 关闭并删除容器</span><br><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 3. 开启 | 关闭 | 重启已经存在的由docker-compose维护的容器</span><br><span class="line">docker-compose start | stop | restart</span><br></pre></td></tr></table></figure><br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 4. 查看由docker-compose管理的容器</span><br><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 5. 查看日志</span><br><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure></p><h2 id="5-4-docker-compose配置Dockerfile使用"><a href="#5-4-docker-compose配置Dockerfile使用" class="headerlink" title="5.4 docker-compose配置Dockerfile使用"></a><strong>5.4 docker-compose配置Dockerfile使用</strong></h2><p> 使用docker-compose.yml文件以及Dockerfile文件在生产自定义镜像的同时启动当前镜像，并且由docker-compose去管理容器<br> docker-compose.yml<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># yml文件</span><br><span class="line">version: &#x27;3.1&#x27;</span><br><span class="line">services:</span><br><span class="line"> ssm:</span><br><span class="line">   restart: always</span><br><span class="line">   build:          # 构建自定义镜像</span><br><span class="line">     context: ../. # 指定dockerfile文件的所在路径</span><br><span class="line">     dockerfile: Dockerfile  # 指定Dockerfile文件名称</span><br><span class="line">   image: ssm:1.0.1</span><br><span class="line">   container_name: ssm</span><br><span class="line">   ports:</span><br><span class="line">     - 8081:8080</span><br><span class="line">   environment:</span><br><span class="line">     TZ: Asia/Shanghai</span><br></pre></td></tr></table></figure><br> Dockerfile文件<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">copy ssm.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure><br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 可以直接启动基于docker-compose.yml以及Dockerfile文件构建的自定义镜像</span><br><span class="line">dockr-compose up -d</span><br><span class="line"># 如果自定义镜像不存在，会帮助我们构建出自定义镜像，如果自定义镜像已经存在，会直接运行这个自定义镜像</span><br><span class="line"># 重新构建的话</span><br><span class="line"># 重新构建自定义镜像</span><br><span class="line">docker-compose build</span><br><span class="line"># 运行前，重新构建</span><br><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/93b3e0fd73f78f9cdc0fda5b5a5ce62f.png&quot;/&gt;

&lt;h1 id=&quot;一-Docker介绍&quot;&gt;&lt;a href=&quot;#一-Docker介绍&quot; class=&quot;headerlink&quot; title=&quot;一.Docker介绍&quot;&gt;&lt;/a&gt;&lt;strong&gt;一.Docker介绍&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt; Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。&lt;br&gt; Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;br&gt; 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;br&gt; Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux其他命令</title>
    <link href="http://example.com/2020/11/12/Linux%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2020/11/12/Linux%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/</id>
    <published>2020-11-12T09:19:49.000Z</published>
    <updated>2021-11-12T09:25:03.017Z</updated>
    
    <content type="html"><![CDATA[<p>收集了一些常用的终端命令，便于需要时使用。本文主要包括：</p><ul><li>查找文件</li><li>软链接</li><li>打包和压缩</li><li>软件安装</li></ul><span id="more"></span><h1 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h1><p>find 命令功能非常强大，通常用来在 特定的目录下 搜索 符合条件的文件<br>序号    命令    作用<br>01    find [路径] -name “*.py”    查找指定路径下扩展名是 .py 的文件，包括子目录<br>如果省略路径，表示在当前文件夹下查找<br>之前学习的通配符，在使用 find 命令时同时可用<br>有关 find 的高级使用，在就业班会讲</p><h1 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h1><p>序号    命令    作用<br>01    ln -s 被链接的源文件 链接文件    建立文件的软链接，用通俗的方式讲类似于 Windows 下的快捷方式<br>注意：<br>没有 -s 选项建立的是一个 硬链接文件<br>两个文件占用相同大小的硬盘空间，工作中几乎不会建立文件的硬链接<br>源文件要使用绝对路径，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用</p><h1 id="硬链接简介"><a href="#硬链接简介" class="headerlink" title="硬链接简介"></a>硬链接简介</h1><p>在使用 ln 创建链接时，如果没有 -s 选项，会创建一个 硬链接，而不是软链接</p><h1 id="文件软硬链接的示意图"><a href="#文件软硬链接的示意图" class="headerlink" title="文件软硬链接的示意图"></a>文件软硬链接的示意图</h1><p>在 Linux 中，文件名 和 文件的数据 是分开存储的</p><p>提示：</p><p>在 Linux 中，只有文件的 硬链接数 == 0 才会被删除<br>使用 ls -l 可以查看一个文件的硬链接的数量<br>在日常工作中，几乎不会建立文件的硬链接，知道即可</p><h1 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h1><p>打包压缩 是日常工作中备份文件的一种方式</p><p>在不同操作系统中，常用的打包压缩方式是不同的</p><p>Windows 常用 rar<br>Mac 常用 zip<br>Linux 常用 tar.gz</p><h2 id="打包-／-解包"><a href="#打包-／-解包" class="headerlink" title="打包 ／ 解包"></a>打包 ／ 解包</h2><p>tar 是 Linux 中最常用的 备份工具，此命令可以 把一系列文件 打包到 一个大文件中，也可以把一个 打包的大文件恢复成一系列文件<br>tar 的命令格式如下：</p><h2 id="打包文件"><a href="#打包文件" class="headerlink" title="打包文件"></a>打包文件</h2><p>tar -cvf 打包文件.tar 被打包的文件／路径…</p><h2 id="解包文件"><a href="#解包文件" class="headerlink" title="解包文件"></a>解包文件</h2><p>tar -xvf 打包文件.tar<br>tar 选项说明<br>选项    含义<br>c    生成档案文件，创建打包文件<br>x    解开档案文件<br>v    列出归档解档的详细过程，显示进度<br>f    指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后<br>注意：f 选项必须放在最后，其他选项顺序可以随意</p><h1 id="压缩／解压缩"><a href="#压缩／解压缩" class="headerlink" title="压缩／解压缩"></a>压缩／解压缩</h1><p>gzip<br>tar 与 gzip 命令结合可以使用实现文件 打包和压缩</p><p>tar 只负责打包文件，但不压缩<br>用 gzip 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.gz<br>在 Linux 中，最常见的压缩文件格式就是 xxx.tar.gz</p><p>在 tar 命令中有一个选项 -z 可以调用 gzip，从而可以方便的实现压缩和解压缩的功能<br>命令格式如下：</p><h2 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h2><p>tar -zcvf 打包文件.tar.gz 被压缩的文件／路径…</p><h2 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h2><p>tar -zxvf 打包文件.tar.gz</p><h2 id="解压缩到指定路径"><a href="#解压缩到指定路径" class="headerlink" title="解压缩到指定路径"></a>解压缩到指定路径</h2><p>tar -zxvf 打包文件.tar.gz -C 目标路径<br>选项    含义<br>-C    解压缩到指定目录，注意：要解压缩的目录必须存在<br>bzip2(two)<br>tar 与 bzip2 命令结合可以使用实现文件 打包和压缩（用法和 gzip 一样）</p><p>tar 只负责打包文件，但不压缩，<br>用 bzip2 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.bz2<br>在 tar 命令中有一个选项 -j 可以调用 bzip2，从而可以方便的实现压缩和解压缩的功能</p><p>命令格式如下：</p><h2 id="压缩文件-1"><a href="#压缩文件-1" class="headerlink" title="压缩文件"></a>压缩文件</h2><p>tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径…</p><h2 id="解压缩文件-1"><a href="#解压缩文件-1" class="headerlink" title="解压缩文件"></a>解压缩文件</h2><p>tar -jxvf 打包文件.tar.bz2</p><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>通过 apt 安装／卸载软件<br>apt 是 Advanced Packaging Tool，是 Linux 下的一款安装包管理工具<br>可以在终端中方便的 安装／卸载／更新软件包</p><h2 id="1-安装软件"><a href="#1-安装软件" class="headerlink" title="1. 安装软件"></a>1. 安装软件</h2><p>$ sudo apt install 软件包</p><h2 id="2-卸载软件"><a href="#2-卸载软件" class="headerlink" title="2. 卸载软件"></a>2. 卸载软件</h2><p>$ sudo apt remove 软件名</p><h2 id="3-更新已安装的包"><a href="#3-更新已安装的包" class="headerlink" title="3. 更新已安装的包"></a>3. 更新已安装的包</h2><p>$ sudo apt upgrade<br>配置软件源<br>如果希望在 ubuntu 中安装软件，更加快速，可以通过设置镜像源，选择一个访问网速更快的服务器，来提供软件下载／安装服务<br>提示：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了<br>所谓镜像源，就是所有服务器的内容是相同的（镜像），但是根据所在位置不同，国内服务器通常速度会更快一些！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;收集了一些常用的终端命令，便于需要时使用。本文主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找文件&lt;/li&gt;
&lt;li&gt;软链接&lt;/li&gt;
&lt;li&gt;打包和压缩&lt;/li&gt;
&lt;li&gt;软件安装&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux用户权限相关命令</title>
    <link href="http://example.com/2020/11/12/linuxuser/"/>
    <id>http://example.com/2020/11/12/linuxuser/</id>
    <published>2020-11-12T09:01:15.000Z</published>
    <updated>2021-11-12T09:05:12.179Z</updated>
    
    <content type="html"><![CDATA[<p>收集了一些常用的终端命令，便于需要时使用。本文主要包括：</p><p>用户 和 权限 的基本概念<br>用户管理 终端命令<br>组管理 终端命令<br>修改权限 终端命令<br>用户 和 权限 的基本概念</p><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>用户 是 Linux 系统工作中重要的一环，用户管理包括 用户 与 组 管理<br>在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限<br>在 Linux 中，可以指定 每一个用户 针对 不同的文件或者目录 的 不同权限<br>对 文件／目录 的权限包括：<br>序号    权限    英文    缩写    数字代号<br>01    读    read    r    4<br>02    写    write    w    2<br>03    执行    excute    x    1</p><h1 id="组"><a href="#组" class="headerlink" title="组"></a>组</h1><p>为了方便用户管理，提出了 组 的概念，如下图所示</p><p>在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限</p><h1 id="ls-l-扩展"><a href="#ls-l-扩展" class="headerlink" title="ls -l 扩展"></a>ls -l 扩展</h1><p>ls -l 可以查看文件夹下文件的详细信息，从左到右依次是：</p><p>权限，第 1 个字符如果是 d 表示目录<br>硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录／文件<br>拥有者，家目录下 文件／目录 的拥有者通常都是当前用户<br>组，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲<br>大小<br>时间<br>名称<br>chmod 简单使用（重要）<br>chmod 可以修改 用户／组 对 文件／目录 的权限<br>命令格式如下：<br>chmod +/-rwx 文件名|目录名<br>提示：以上方式会一次性修改 拥有者 / 组 权限</p><h1 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h1><p>Linux 系统中的 root 账号通常 用于系统的维护和管理，对操作系统的所有资源 具有所有访问权限<br>在大多数版本的 Linux 中，都不推荐 直接使用 root 账号登录系统<br>在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户”</p><h1 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h1><p>su 是 substitute user 的缩写，表示 使用另一个用户的身份<br>sudo 命令用来以其他身份来执行命令，预设的身份为 root<br>用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码<br>若其未经授权的用户企图使用 sudo，则会发出警告邮件给管理员</p><h1 id="组管理-终端命令"><a href="#组管理-终端命令" class="headerlink" title="组管理 终端命令"></a>组管理 终端命令</h1><p>提示：创建组 / 删除组 的终端命令都需要通过 sudo 执行</p><p>序号    命令    作用<br>01    groupadd 组名    添加组<br>02    groupdel 组名    删除组<br>03    cat /etc/group    确认组信息<br>04    chgrp -R 组名 文件/目录名    递归修改文件/目录的所属组<br>提示：</p><p>组信息保存在 /etc/group 文件中<br>/etc 目录是专门用来保存 系统配置信息 的目录<br>在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限</p><h1 id="用户管理-终端命令"><a href="#用户管理-终端命令" class="headerlink" title="用户管理 终端命令"></a>用户管理 终端命令</h1><p>提示：创建用户 / 删除用户 / 修改其他用户密码 的终端命令都需要通过 sudo 执行</p><h1 id="3-1-创建用户／设置密码／删除用户"><a href="#3-1-创建用户／设置密码／删除用户" class="headerlink" title="3.1 创建用户／设置密码／删除用户"></a>3.1 创建用户／设置密码／删除用户</h1><p>序号    命令    作用    说明<br>01    useradd -m -g 组 新建用户名    添加新用户    -m 自动建立用户家目录<br>-g 指定用户所在的组，否则会建立一个和同名的组<br>02    passwd 用户名    设置用户密码    如果是普通用户，直接用 passwd 可以修改自己的账户密码<br>03    userdel -r 用户名    删除用户    -r 选项会自动删除用户家目录<br>04    cat /etc/passwd    grep 用户名    确认用户信息    新建用户后，用户信息会保存在 /etc/passwd 文件中<br>提示：</p><p>创建用户时，如果忘记添加 -m 选项指定新用户的家目录 —— 最简单的方法就是删除用户，重新创建<br>创建用户时，默认会创建一个和用户名同名的组名<br>用户信息保存在 /etc/passwd 文件中</p><h1 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h1><p>序号    命令    作用<br>01    id [用户名]    查看用户 UID 和 GID 信息<br>02    who    查看当前所有登录的用户列表<br>03    whoami    查看当前登录用户的账户名<br><strong>passwd 文件</strong><br>/etc/passwd 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是</p><p>用户名<br>密码（x，表示加密的密码）<br>UID（用户标识）<br>GID（组标识）<br>用户全名或本地帐号<br>家目录<br>登录使用的 Shell，就是登录之后，使用的终端命令，ubuntu 默认是 dash<br><strong>usermod</strong><br>usermod 可以用来设置 用户 的 主组 ／ 附加组 和 登录 Shell，命令格式如下：<br>主组：通常在新建用户时指定，在 etc/passwd 的第 4 列 GID 对应的组<br>附加组：在 etc/group 中最后一列表示该组的用户列表，用于指定 用户的附加权限<br>提示：设置了用户的附加组之后，需要重新登录才能生效！</p><h1 id="修改用户的主组（passwd-中的-GID）"><a href="#修改用户的主组（passwd-中的-GID）" class="headerlink" title="修改用户的主组（passwd 中的 GID）"></a>修改用户的主组（passwd 中的 GID）</h1><p>usermod -g 组 用户名</p><h1 id="修改用户的附加组"><a href="#修改用户的附加组" class="headerlink" title="修改用户的附加组"></a>修改用户的附加组</h1><p>usermod -G 组 用户名</p><h1 id="修改用户登录-Shell"><a href="#修改用户登录-Shell" class="headerlink" title="修改用户登录 Shell"></a>修改用户登录 Shell</h1><p>usermod -s /bin/bash 用户名<br>注意：默认使用 useradd 添加的用户是没有权限使用 sudo 以 root 身份执行命令的，可以使用以下命令，将用户添加到 sudo 附加组中</p><p>usermod -G sudo 用户名</p><p><strong>which（重要）</strong><br>提示</p><p>/etc/passwd 是用于保存用户信息的文件<br>/usr/bin/passwd 是用于修改用户密码的程序<br>which 命令可以查看执行命令所在位置，例如：<br>which ls</p><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><h1 id="bin-ls"><a href="#bin-ls" class="headerlink" title="/bin/ls"></a>/bin/ls</h1><p>which useradd</p><h1 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h1><h1 id="usr-sbin-useradd"><a href="#usr-sbin-useradd" class="headerlink" title="/usr/sbin/useradd"></a>/usr/sbin/useradd</h1><p>bin 和 sbin<br>在 Linux 中，绝大多数可执行文件都是保存在 /bin、/sbin、/usr/bin、/usr/sbin<br>/bin（binary）是二进制执行文件目录，主要用于具体应用<br>/sbin（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理<br>/usr/bin（user commands for applications）后期安装的一些软件<br>/usr/sbin（super user commands for applications）超级用户的一些管理程序<br>提示：</p><p>cd 这个终端命令是内置在系统内核中的，没有独立的文件，因此用 which 无法找到 cd 命令的位置</p><h1 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h1><p>序号    命令    作用    说明<br>01    su - 用户名    切换用户，并且切换目录    - 可以切换到用户家目录，否则保持位置不变<br>02    exit    退出当前登录账户<br>su 不接用户名，可以切换到 root，但是不推荐使用，因为不安全<br>exit 示意图如下：</p><h1 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h1><p>序号    命令    作用<br>01    chown    修改拥有者<br>02    chgrp    修改组<br>03    chmod    修改权限<br>命令格式如下：</p><h1 id="修改文件-目录的拥有者"><a href="#修改文件-目录的拥有者" class="headerlink" title="修改文件|目录的拥有者"></a>修改文件|目录的拥有者</h1><p>chown 用户名 文件名|目录名</p><h1 id="递归修改文件-目录的组"><a href="#递归修改文件-目录的组" class="headerlink" title="递归修改文件|目录的组"></a>递归修改文件|目录的组</h1><p>chgrp -R 组名 文件名|目录名</p><h1 id="递归修改文件权限"><a href="#递归修改文件权限" class="headerlink" title="递归修改文件权限"></a>递归修改文件权限</h1><p>chmod -R 755 文件名|目录名<br>chmod 在设置权限时，可以简单地使用三个数字分别对应 拥有者 ／ 组 和 其他 用户的权限</p><h1 id="直接修改文件-目录的-读-写-执行-权限，但是不能精确到-拥有者-组-其他"><a href="#直接修改文件-目录的-读-写-执行-权限，但是不能精确到-拥有者-组-其他" class="headerlink" title="直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他"></a>直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他</h1><p>chmod +/-rwx 文件名|目录名<br>常见数字组合有（u表示用户／g表示组／o表示其他）：</p><p>777 ===&gt; u=rwx,g=rwx,o=rwx* 755 ===&gt; u=rwx,g=rx,o=rx<br>644 ===&gt; u=rw,g=r,o=r</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;收集了一些常用的终端命令，便于需要时使用。本文主要包括：&lt;/p&gt;
&lt;p&gt;用户 和 权限 的基本概念&lt;br&gt;用户管理 终端命令&lt;br&gt;组管理 终端命令&lt;br&gt;修改权限 终端命令&lt;br&gt;用户 和 权限 的基本概念&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux远程管理常用命令</title>
    <link href="http://example.com/2020/11/12/linux/"/>
    <id>http://example.com/2020/11/12/linux/</id>
    <published>2020-11-12T08:57:50.000Z</published>
    <updated>2021-11-12T09:01:47.263Z</updated>
    
    <content type="html"><![CDATA[<p><strong>收集了一些常用的终端命令，便于需要时使用。本文主要包括：</strong></p><ul><li>关机/重启</li><li>查看或配置网卡信息</li><li>远程登录和复制文件<span id="more"></span>关机/重启<br>序号    命令    对应英文    作用<br>01    shutdown 选项 时间    shutdown    关机／重新启动<br>shutdown<br>shutdown 命令可以 安全 关闭 或者 重新启动系统<br>选项    含义</li><li>r    重新启动<br>提示：</li></ul><p>不指定选项和参数，默认表示 1 分钟之后 关闭电脑<br>远程维护服务器时，最好不要关闭系统，而应该重新启动系统<br>常用命令示例</p><h1 id="重新启动操作系统，其中-now-表示现在"><a href="#重新启动操作系统，其中-now-表示现在" class="headerlink" title="重新启动操作系统，其中 now 表示现在"></a>重新启动操作系统，其中 now 表示现在</h1><p>$ shutdown -r now</p><h1 id="立刻关机，其中-now-表示现在"><a href="#立刻关机，其中-now-表示现在" class="headerlink" title="立刻关机，其中 now 表示现在"></a>立刻关机，其中 now 表示现在</h1><p>$ shutdown now</p><h1 id="系统在今天的-20-25-会关机"><a href="#系统在今天的-20-25-会关机" class="headerlink" title="系统在今天的 20:25 会关机"></a>系统在今天的 20:25 会关机</h1><p>$ shutdown 20:25</p><h1 id="系统再过十分钟后自动关机"><a href="#系统再过十分钟后自动关机" class="headerlink" title="系统再过十分钟后自动关机"></a>系统再过十分钟后自动关机</h1><p>$ shutdown +10</p><h1 id="取消之前指定的关机计划"><a href="#取消之前指定的关机计划" class="headerlink" title="取消之前指定的关机计划"></a>取消之前指定的关机计划</h1><p>$ shutdown -c</p><p>查看或配置网卡信息<br>序号    命令    对应英文    作用<br>01    ifconfig    configure a network interface    查看/配置计算机当前的网卡配置信息<br>02    ping ip地址    ping    检测到目标 ip地址 的连接是否正常<br>网卡 和 IP 地址<br>网卡<br>网卡是一个专门负责网络通讯的硬件设备<br>IP 地址是设置在网卡上的地址信息<br>我们可以把 电脑 比作 电话，网卡 相当于 SIM 卡，IP 地址 相当于 电话号码</p><p>IP 地址<br>每台联网的电脑上都有 IP 地址，是保证电脑之间正常通讯的重要设置<br>注意：每台电脑的 IP 地址不能相同，否则会出现 IP 地址冲突，并且没有办法正常通讯</p><p>ifconfig<br>ifconfig 可以查看／配置计算机当前的网卡配置信息</p><h1 id="查看网卡配置信息"><a href="#查看网卡配置信息" class="headerlink" title="查看网卡配置信息"></a>查看网卡配置信息</h1><p>$ ifconfig</p><h1 id="查看网卡对应的-IP-地址"><a href="#查看网卡对应的-IP-地址" class="headerlink" title="查看网卡对应的 IP 地址"></a>查看网卡对应的 IP 地址</h1><p>$ ifconfig | grep inet<br>提示：一台计算机中有可能会有一个 物理网卡 和 多个虚拟网卡，在 Linux 中物理网卡的名字通常以 ensXX 表示</p><p>127.0.0.1 被称为 本地回环/环回地址，一般用来测试本机网卡是否正常<br>ping</p><h1 id="检测到目标主机是否连接正常"><a href="#检测到目标主机是否连接正常" class="headerlink" title="检测到目标主机是否连接正常"></a>检测到目标主机是否连接正常</h1><p>$ ping IP地址</p><h1 id="检测本地网卡工作正常"><a href="#检测本地网卡工作正常" class="headerlink" title="检测本地网卡工作正常"></a>检测本地网卡工作正常</h1><p>$ ping 127.0.0.1<br>ping 一般用于检测当前计算机到目标计算机之间的网络 是否通畅，数值越大，速度越慢<br>ping 的工作原理与潜水艇的声纳相似，ping 这个命令就是取自 声纳的声音* 网络管理员之间也常将 ping 用作动词 —— ping 一下计算机X，看他是否开着<br>原理：网络上的机器都有 唯一确定的 IP 地址，我们给目标 IP 地址发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在</p><p>提示：在 Linux 中，想要终止一个终端程序的执行，绝大多数都可以使用 CTRL + C</p><p>远程登录和复制文件<br>序号    命令    对应英文    作用<br>01    ssh 用户名@ip    secure shell    关机／重新启动<br>02    scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径    secure copy    远程复制文件<br>ssh 基础<br>在 Linux 中 SSH 是 非常常用 的工具，通过 SSH 客户端 我们可以连接到运行了 SSH 服务器 的远程机器上</p><p>001_SSH示意图<br>SSH 客户端是一种使用 Secure Shell（SSH） 协议连接到远程计算机的软件程序<br>SSH 是目前较可靠，专为远程登录会话和其他网络服务 提供安全性的协议<br>利用 SSH 协议 可以有效防止远程管理过程中的信息泄露<br>通过 SSH 协议 可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗<br>SSH 的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度<br>域名 和 端口号<br>域名<br>由一串 用点分隔 的名字组成，例如：<a href="http://www.itcast.cn/">www.itcast.cn</a><br>是 IP 地址 的别名，方便用户记忆<br>端口号<br>IP 地址：通过 IP 地址 找到网络上的 计算机</p><p>端口号：通过 端口号 可以找到 计算机上运行的应用程序</p><p>SSH 服务器 的默认端口号是 22，如果是默认端口号，在连接的时候，可以省略</p><p>常见服务端口号列表：</p><p>序号    服务    端口号<br>01    SSH 服务器    22<br>02    Web 服务器    80<br>03    HTTPS    443<br>04    FTP 服务器    21<br>SSH 客户端的简单使用<br>ssh [-p port] user@remote<br>user 是在远程机器上的用户名，如果不指定的话默认为当前用户<br>remote 是远程机器的地址，可以是 IP／域名，或者是 后面会提到的别名<br>port 是 SSH Server 监听的端口，如果不指定，就为默认值 22<br>提示：</p><p>使用 exit 退出当前用户的登录<br>注意：</p><p>ssh 这个终端命令只能在 Linux 或者 UNIX 系统下使用</p><p>如果在 Windows 系统中，可以安装 PuTTY 或者 XShell 客户端软件即可</p><p>提示：</p><p>在工作中，SSH 服务器的端口号很有可能不是 22，如果遇到这种情况就需要使用 -p 选项，指定正确的端口号，否则无法正常连接到服务器</p><p>Windows 下 SSH 客户端的安装<br>Putty<br>XShell<br>建议从官方网站下载正式的安装程序</p><p>scp<br>scp 就是 secure copy，是一个在 Linux 下用来进行 远程拷贝文件 的命令<br>它的地址格式与 ssh 基本相同，需要注意的是，在指定端口时用的是大写的 -P 而不是小写的<br>002_SCP示意图</p><h1 id="把本地当前目录下的-01-py-文件-复制到-远程-家目录下的-Desktop-01-py"><a href="#把本地当前目录下的-01-py-文件-复制到-远程-家目录下的-Desktop-01-py" class="headerlink" title="把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py"></a>把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py</h1><h1 id="注意：-后面的路径如果不是绝对路径，则以用户的家目录作为参照路径"><a href="#注意：-后面的路径如果不是绝对路径，则以用户的家目录作为参照路径" class="headerlink" title="注意：: 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径"></a>注意：<code>:</code> 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径</h1><p>scp -P port 01.py user@remote:Desktop/01.py</p><h1 id="把远程-家目录下的-Desktop-01-py-文件-复制到-本地当前目录下的-01-py"><a href="#把远程-家目录下的-Desktop-01-py-文件-复制到-本地当前目录下的-01-py" class="headerlink" title="把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py"></a>把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py</h1><p>scp -P port user@remote:Desktop/01.py 01.py</p><h1 id="加上-r-选项可以传送文件夹"><a href="#加上-r-选项可以传送文件夹" class="headerlink" title="加上 -r 选项可以传送文件夹"></a>加上 -r 选项可以传送文件夹</h1><h1 id="把当前目录下的-demo-文件夹-复制到-远程-家目录下的-Desktop"><a href="#把当前目录下的-demo-文件夹-复制到-远程-家目录下的-Desktop" class="headerlink" title="把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop"></a>把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop</h1><p>scp -r demo user@remote:Desktop</p><h1 id="把远程-家目录下的-Desktop-复制到-当前目录下的-demo-文件夹"><a href="#把远程-家目录下的-Desktop-复制到-当前目录下的-demo-文件夹" class="headerlink" title="把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹"></a>把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹</h1><p>scp -r user@remote:Desktop demo<br>选项    含义<br>-r    若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名<br>-P    若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口<br>注意：</p><p>scp 这个终端命令只能在 Linux 或者 UNIX 系统下使用<br>如果在 Windows 系统中，可以安装 PuTTY，使用 pscp 命令行工具或者安装 FileZilla 使用 FTP 进行文件传输<br>FileZilla<br>官方网站：<a href="https://www.filezilla.cn/download/client">https://www.filezilla.cn/download/client</a><br>FileZilla 在传输文件时，使用的是 FTP 服务 而不是 SSH 服务，因此端口号应该设置为 21<br>SSH 高级<br>免密码登录<br>配置别名<br>提示：有关 SSH 配置信息都保存在用户家目录下的 .ssh 目录下</p><p>免密码登录<br>步骤<br>配置公钥</p><p>执行 ssh-keygen 即可生成 SSH 钥匙，一路回车即可<br>上传公钥到服务器</p><p>执行 ssh-copy-id -p port user@remote，可以让远程服务器记住我们的公钥<br>示意图<br>003_SSH 免密码示意图<br>非对称加密算法</p><p>使用 公钥 加密的数据，需要使用 私钥 解密<br>使用 私钥 加密的数据，需要使用 公钥 解密<br>配置别名<br>每次都输入 ssh -p port user@remote，时间久了会觉得很麻烦，特别是当 user, remote 和 port 都得输入，而且还不好记忆</p><p>而 配置别名 可以让我们进一步偷懒，譬如用：ssh mac 来替代上面这么一长串，那么就在 ~/.ssh/config 里面追加以下内容：</p><p>Host Mac<br>HostName ip地址<br>User username<br>Port 22<br>保存之后，即可用 ssh mac 实现远程登录了，scp 同样可以使用</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;收集了一些常用的终端命令，便于需要时使用。本文主要包括：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关机/重启&lt;/li&gt;
&lt;li&gt;查看或配置网卡信息&lt;/li&gt;
&lt;li&gt;远程登录和复制文件</summary>
    
    
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
</feed>
